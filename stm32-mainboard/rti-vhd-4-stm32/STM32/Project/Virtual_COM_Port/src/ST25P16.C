#include "ST25P16.h"

/**************************************************************/

//#define FPGA_EPCS

unsigned int g_wTimers;
 byte  bpData[1370]=
{
	0x34,0x35,0x20,0x33,0x33,0x20,0x35,0x34,0x20,0x35,0x32,0x20,0x30,0x64,0x20,0x30,
	0x61,0x20,0x20,0x2F,0x2F,0x6E,0x65,0x78,0x74,0x70,0x61,0x67,0x65,0x0D,0x0A,0x34,
	0x35,0x20,0x33,0x33,0x20,0x35,0x34,0x20,0x33,0x37,0x20,0x30,0x64,0x20,0x30,0x61,
	0x20,0x20,0x2F,0x2F,0x6E,0x65,0x78,0x74,0x77,0x65,0x62,0x0D,0x0A,0x34,0x35,0x20,
	0x33,0x33,0x20,0x35,0x34,0x20,0x35,0x31,0x20,0x30,0x64,0x20,0x30,0x61,0x20,0x20,
	0x2F,0x2F,0xD6,0xD8,0xB4,0xAB,0x0D,0x0A,0x34,0x35,0x20,0x33,0x33,0x20,0x35,0x34,
	0x20,0x35,0x33,0x20,0x30,0x44,0x20,0x30,0x41,0x20,0x20,0x2F,0x2F,0xC3,0xFC,0xC1,
	0xEE,0xB4,0xED,0xCE,0xF3,0x0D,0x0A,0x0D,0x0A,0x75,0x73,0x65,0x72,0x70,0x61,0x73,
	0x73,0x77,0x6F,0x72,0x64,0x5F,0x70,0x61,0x72,0x3D,0x61,0x61,0x33,0x31,0x34,0x39,
	0x30,0x33,0x31,0x37,0x35,0x26,0x4F,0x70,0x74,0x69,0x6F,0x6E,0x4B,0x65,0x79,0x3D,
	0x31,0x26,0x4F,0x70,0x74,0x69,0x6F,0x6E,0x4B,0x65,0x79,0x3D,0x35,0x26,0x4F,0x70,
	0x74,0x69,0x6F,0x6E,0x4B,0x65,0x79,0x3D,0x32,0x26,0x6D,0x61,0x63,0x61,0x64,0x64,
	0x72,0x65,0x73,0x73,0x5F,0x70,0x61,0x72,0x3D,0x35,0x34,0x2D,0x35,0x35,0x2D,0x35,
	0x38,0x2D,0x31,0x30,0x2D,0x30,0x30,0x2D,0x32,0x34,0x26,0x69,0x70,0x61,0x64,0x64,
	0x72,0x65,0x73,0x73,0x5F,0x70,0x61,0x72,0x3D,0x31,0x39,0x32,0x2E,0x31,0x36,0x38,
	0x2E,0x31,0x2E,0x31,0x30,0x33,0x2B,0x2B,0x26,0x6D,0x61,0x73,0x6B,0x5F,0x70,0x61,
	0x72,0x3D,0x32,0x35,0x35,0x2E,0x32,0x35,0x35,0x2E,0x32,0x35,0x35,0x2E,0x30,0x2B,
	0x2B,0x26,0x67,0x61,0x74,0x65,0x77,0x61,0x79,0x5F,0x70,0x61,0x72,0x3D,0x31,0x39,
	0x32,0x2E,0x31,0x36,0x38,0x2E,0x31,0x2E,0x31,0x2B,0x2B,0x2B,0x2B,0x26,0x64,0x6E,
	0x73,0x73,0x65,0x72,0x76,0x65,0x72,0x5F,0x70,0x61,0x72,0x3D,0x31,0x39,0x32,0x2E,
	0x31,0x36,0x38,0x2E,0x31,0x2E,0x31,0x2B,0x2B,0x2B,0x2B,0x26,0x63,0x6D,0x64,0x70,
	0x6F,0x72,0x74,0x5F,0x70,0x61,0x72,0x3D,0x32,0x33,0x20,0x48,0x54,0x54,0x50,0x2F,
	0x31,0x2E,0x31,0x0D,0x0A,0x0D,0x0A,0x23,0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x20,
	0x4C,0x6F,0x67,0x69,0x6E,0x50,0x61,0x67,0x65,0x48,0x74,0x6D,0x6C,0x20,0x20,0x30,
	0x20,0x20,0x0D,0x0A,0x23,0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x20,0x4F,0x70,0x74,
	0x69,0x6F,0x6E,0x48,0x74,0x6D,0x6C,0x20,0x20,0x20,0x20,0x31,0x20,0x20,0x0D,0x0A,
	0x23,0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x20,0x4B,0x65,0x79,0x70,0x61,0x67,0x65,
	0x48,0x74,0x6D,0x6C,0x20,0x32,0x0D,0x0A,0x0D,0x0A,0x23,0x64,0x65,0x66,0x69,0x6E,
	0x65,0x20,0x20,0x4C,0x6F,0x67,0x69,0x6E,0x50,0x61,0x67,0x65,0x43,0x73,0x73,0x20,
	0x33,0x0D,0x0A,0x23,0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x20,0x4F,0x70,0x74,0x69,
	0x6F,0x6E,0x43,0x73,0x73,0x20,0x20,0x34,0x0D,0x0A,0x23,0x64,0x65,0x66,0x69,0x6E,
	0x65,0x20,0x20,0x4B,0x65,0x79,0x70,0x61,0x67,0x65,0x43,0x73,0x73,0x20,0x20,0x35,
	0x0D,0x0A,0x0D,0x0A,0x23,0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x20,0x4C,0x6F,0x67,
	0x69,0x6E,0x50,0x61,0x67,0x65,0x4A,0x61,0x76,0x61,0x53,0x63,0x72,0x69,0x70,0x74,
	0x20,0x36,0x0D,0x0A,0x23,0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x20,0x4F,0x70,0x74,
	0x69,0x6F,0x6E,0x4A,0x61,0x76,0x61,0x53,0x63,0x72,0x69,0x70,0x74,0x20,0x20,0x37,
	0x0D,0x0A,0x23,0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x20,0x4B,0x65,0x79,0x70,0x61,
	0x67,0x65,0x4A,0x61,0x76,0x61,0x53,0x63,0x72,0x69,0x70,0x74,0x20,0x20,0x38,0x0D,
	0x0A,0x0D,0x0A,0x0D,0x0A,0x2F,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
	0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0xCD,0xBC,0xC6,0xAC,0xC7,0xF8,0x2A,
	0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
	0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2F,0x0D,
	0x0A,0x0D,0x0A,0x0D,0x0A,0x23,0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x4C,0x6F,0x67,
	0x69,0x6E,0x50,0x61,0x67,0x65,0x50,0x69,0x63,0x74,0x75,0x72,0x65,0x20,0x30,0x0D,
	0x0A,0x23,0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x4F,0x70,0x74,0x69,0x6F,0x6E,0x50,
	0x69,0x63,0x74,0x75,0x72,0x65,0x20,0x31,0x0D,0x0A,0x2F,0x2A,0x2A,0x2A,0x2A,0x2A,
	0x2A,0x2A,0x2A,0x2A,0x42,0x75,0x6C,0x65,0x4B,0x45,0x59,0x2A,0x2A,0x2A,0x2A,0x2A,
	0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2F,0x0D,0x0A,0x23,0x64,
	0x65,0x66,0x69,0x6E,0x65,0x20,0x4B,0x65,0x79,0x70,0x61,0x67,0x65,0x50,0x69,0x63,
	0x74,0x75,0x72,0x65,0x42,0x75,0x6C,0x65,0x31,0x20,0x32,0x0D,0x0A,0x23,0x64,0x65,
	0x66,0x69,0x6E,0x65,0x20,0x4B,0x65,0x79,0x70,0x61,0x67,0x65,0x50,0x69,0x63,0x74,
	0x75,0x72,0x65,0x42,0x75,0x6C,0x65,0x32,0x20,0x33,0x0D,0x0A,0x23,0x64,0x65,0x66,
	0x69,0x6E,0x65,0x20,0x4B,0x65,0x79,0x70,0x61,0x67,0x65,0x50,0x69,0x63,0x74,0x75,
	0x72,0x65,0x42,0x75,0x6C,0x65,0x33,0x20,0x34,0x0D,0x0A,0x23,0x64,0x65,0x66,0x69,
	0x6E,0x65,0x20,0x4B,0x65,0x79,0x70,0x61,0x67,0x65,0x50,0x69,0x63,0x74,0x75,0x72,
	0x65,0x42,0x75,0x6C,0x65,0x34,0x20,0x35,0x0D,0x0A,0x2F,0x2A,0x2A,0x2A,0x2A,0x2A,
	0x2A,0x2A,0x2A,0x2A,0x47,0x72,0x65,0x65,0x6E,0x4B,0x45,0x59,0x2A,0x2A,0x2A,0x2A,
	0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2F,0x0D,0x0A,0x23,
	0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x4B,0x65,0x79,0x70,0x61,0x67,0x65,0x50,0x69,
	0x63,0x74,0x75,0x72,0x65,0x47,0x72,0x65,0x65,0x6E,0x31,0x20,0x36,0x0D,0x0A,0x23,
	0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x4B,0x65,0x79,0x70,0x61,0x67,0x65,0x50,0x69,
	0x63,0x74,0x75,0x72,0x65,0x47,0x72,0x65,0x65,0x6E,0x32,0x20,0x37,0x0D,0x0A,0x23,
	0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x4B,0x65,0x79,0x70,0x61,0x67,0x65,0x50,0x69,
	0x63,0x74,0x75,0x72,0x65,0x47,0x72,0x65,0x65,0x6E,0x33,0x20,0x38,0x0D,0x0A,0x23,
	0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x4B,0x65,0x79,0x70,0x61,0x67,0x65,0x50,0x69,
	0x63,0x74,0x75,0x72,0x65,0x47,0x72,0x65,0x65,0x6E,0x34,0x20,0x39,0x0D,0x0A,0x0D,
	0x0A,0x0D,0x0A,0x2F,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x4D,0x49,0x43,
	0x20,0x20,0x4C,0x49,0x4E,0x45,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
	0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2F,0x0D,0x0A,0x23,0x64,0x65,0x66,0x69,0x6E,0x65,
	0x20,0x4B,0x65,0x79,0x70,0x61,0x67,0x65,0x50,0x69,0x63,0x74,0x75,0x72,0x65,0x41,
	0x72,0x72,0x6F,0x77,0x73,0x55,0x70,0x20,0x31,0x30,0x0D,0x0A,0x23,0x64,0x65,0x66,
	0x69,0x6E,0x65,0x20,0x4B,0x65,0x79,0x70,0x61,0x67,0x65,0x50,0x69,0x63,0x74,0x75,
	0x72,0x65,0x41,0x72,0x72,0x6F,0x77,0x73,0x44,0x6F,0x77,0x6E,0x20,0x31,0x31,0x0D,
	0x0A,0x23,0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x4B,0x65,0x79,0x70,0x61,0x67,0x65,
	0x50,0x69,0x63,0x74,0x75,0x72,0x65,0x4D,0x75,0x74,0x65,0x20,0x31,0x32,0x0D,0x0A,
	0x23,0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x4B,0x65,0x79,0x70,0x61,0x67,0x65,0x50,
	0x69,0x63,0x74,0x75,0x72,0x65,0x56,0x6F,0x6C,0x75,0x6D,0x65,0x20,0x31,0x33,0x0D,
	0x0A,0x0D,0x0A,0x2F,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x41,0x44,0x4A,
	0x55,0x53,0x54,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
	0x2A,0x2A,0x2A,0x2F,0x0D,0x0A,0x23,0x64,0x65,0x66,0x69,0x6E,0x65,0x20,0x4B,0x65,
	0x79,0x70,0x61,0x67,0x65,0x50,0x69,0x63,0x74,0x75,0x72,0x65,0x41,0x64,0x6A,0x75,
	0x73,0x74,0x20,0x31,0x34,0x0D,0x0A,0x0D,0x0A,0x0D,0x0A,0x2F,0x2A,0x2A,0x2A,0x2A,
	0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x61,0x6A,0x61,0x78,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,
	0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2A,0x2F,0x0D,0x0A,0x23,0x64,0x65,0x66,0x69,0x6E,
	0x65,0x20,0x4B,0x65,0x79,0x70,0x61,0x67,0x65,0x41,0x4A,0x41,0x58,0x20,0x31,0x33,
	0x0D,0x0A,0x0D,0x0A,0x0D,0x0A,0x0D,0x0A,0x0D,0x0A,
};

 byte  RDData[4096];
enum
{
        SPI_FLASH_SRWD        = 0x80,                                // Status Register Write Protect
        SPI_FLASH_BP2        = 0x10,                                // Block Protect Bit2
        SPI_FLASH_BP1        = 0x08,                                // Block Protect Bit1
        SPI_FLASH_BP0        = 0x04,                                // Block Protect Bit0
        SPI_FLASH_WEL        = 0x02,                                // write enable latch
        SPI_FLASH_WIP        = 0x01                                // write/program/erase in progress indicator
};
enum
{
        SPI_FLASH_INS_WREN        = 0x06,                // write enable
        SPI_FLASH_INS_WRDI        = 0x04,                // write disable
        SPI_FLASH_INS_RDSR        = 0x05,                // read status register
        SPI_FLASH_INS_WRSR        = 0x01,                // write status register
        SPI_FLASH_INS_READ        = 0x03,                // read data bytes
        SPI_FLASH_INS_FAST_READ   = 0x0B,                // read data bytes at higher speed
        SPI_FLASH_INS_PP          = 0x02,                // page program
        SPI_FLASH_INS_SE          = 0xD8,                // sector erase
        SPI_FLASH_INS_RDID        = 0x9F,                // read identification
        SPI_FLASH_INS_BE          = 0xC7                // bulk erase
};

//TIM2定时器
/*-----------------------------------------------------------------------
tim2 配置	  1秒钟中断一次
--------------------------------------------------------------------*/
void TIME_Config(void)
{
 /*  结构声明*/
  NVIC_InitTypeDef NVIC_InitStructure;
  TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;

  NVIC_PriorityGroupConfig(NVIC_PriorityGroup_1);
  NVIC_InitStructure.NVIC_IRQChannel=TIM2_IRQn; //选择TIM2中断
  NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1;//
  NVIC_InitStructure.NVIC_IRQChannelSubPriority=1; //
  NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;//使能
  NVIC_Init(&NVIC_InitStructure);



RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);
TIM_DeInit(TIM2); //复位定时器
TIM_TimeBaseStructure.TIM_Period=200; //定时器初始值      1/2K*100=100ms
TIM_TimeBaseStructure.TIM_Prescaler=(36000-1); //时钟预分频	   72M/36000=2K时钟
TIM_TimeBaseStructure.TIM_ClockDivision=TIM_CKD_DIV1; // 时钟分割
TIM_TimeBaseStructure.TIM_CounterMode=TIM_CounterMode_Up;//向上计数模式
TIM_TimeBaseInit(TIM2,&TIM_TimeBaseStructure); //初始化定时器的值
TIM_ClearFlag(TIM2,TIM_FLAG_Update); //清除定时器中断标志
TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE); //使能中断
TIM_Cmd(TIM2,ENABLE); //开启时钟


}
/************************************************************************
                                                        自定义函数        
************************************************************************/


//初始化数据切换器
/*
对应管脚PC4  BEA    PD2  BEB
BEA BEB   B0-B4     B5-B9     Function
H    H    Hi-Z       Hi-Z      Disconnect
L    H    A0-A4      Hi-Z      Connect                STM32
H    L    Hi-Z       A5-A9     Connect                FPGA
L    L    A0-A4      A5-A9     Connect
*/
void QS3L384_init(void)
{

  GPIO_InitTypeDef GPIO_InitStructure;
  RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOC, ENABLE);
 //PC4  BEA 数据脚
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4;	
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;       
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOC, &GPIO_InitStructure);

  RCC_APB2PeriphClockCmd( RCC_APB2Periph_GPIOD, ENABLE);
  //PD2  BEB
  GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;	
  GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;       
  GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
  GPIO_Init(GPIOD, &GPIO_InitStructure);

#define IO_H    1
#define IO_L    0
  
#ifdef  FPGA_EPCS
 //初始化设置，默认切到烧写FPGA
QS3L384_BEA=IO_H;
QS3L384_BEB=IO_L;
#else
QS3L384_BEA=IO_L;
QS3L384_BEB=IO_H;
#endif 
}



void ST25P16_init(void)
{
//**************************flash 相关引脚的配置************************************
   //FLASH 片选脚
#if(FLASH_CE_IO >= 8)
	   FLASH_CE_PORT->CRH&=~(((uint32_t)0xf) << (FLASH_CE_IO-8)*4);	//把IO口设置为通用推挽输出，速度50Mhz  
	   FLASH_CE_PORT->CRH|= (((uint32_t)0x3) << (FLASH_CE_IO-8)*4);
#else
	   FLASH_CE_PORT->CRL&=~(((uint32_t)0xf) << FLASH_CE_IO*4);		  
	   FLASH_CE_PORT->CRL|= (((uint32_t)0x3) << FLASH_CE_IO*4);
#endif

   //FLASH 时钟脚
#if(FLASH_CLK_IO >= 8)
	   FLASH_CLK_PORT->CRH&=~(((uint32_t)0xf) << (FLASH_CLK_IO-8)*4);       //把IO口设置为通用推挽输出，速度50Mhz    
	   FLASH_CLK_PORT->CRH|= (((uint32_t)0x3) << (FLASH_CLK_IO-8)*4);
#else
	   FLASH_CLK_PORT->CRL&=~(((uint32_t)0xf) << FLASH_CLK_IO*4);		  
	   FLASH_CLK_PORT->CRL|= (((uint32_t)0x3) << FLASH_CLK_IO*4);
#endif 

   //FLASH 数据输出
#if(FLASH_DIN_IO >= 8)
	   FLASH_DIN_PORT->CRH&=~(((uint32_t)0xf) << (FLASH_DIN_IO-8)*4);	      //把IO口设置为通用推挽输出，速度50Mhz   
	   FLASH_DIN_PORT->CRH|= (((uint32_t)0x3) << (FLASH_DIN_IO-8)*4);
#else
	   FLASH_DIN_PORT->CRL&=~(((uint32_t)0xf) << FLASH_DIN_IO*4);		  
	   FLASH_DIN_PORT->CRL|= (((uint32_t)0x3) << FLASH_DIN_IO*4);
#endif
 
   //FLASH数据输入
#if(FLASH_DOUT_IO >= 8)
	   FLASH_DOUT_PORT->CRH&=~(((uint32_t)0xf) << (FLASH_DOUT_IO-8)*4);         //把IO口设置为浮空输入模式   
	   FLASH_DOUT_PORT->CRH|= (((uint32_t)0x4) << (FLASH_DOUT_IO-8)*4);
#else
	   FLASH_DOUT_PORT->CRL&=~(((uint32_t)0xf) << FLASH_DOUT_IO*4);		  
	   FLASH_DOUT_PORT->CRL|= (((uint32_t)0x4) << FLASH_DOUT_IO*4);
#endif 
     
}

/************************************************************************
函数功能:        flash配置
入口参数:        opt:0/1/2
                                1:flash使能
                                2:flash失能
                                0:不改变
出口参数:        无
************************************************************************/
void ConfigureSpiMaster( byte opt)
{
        if(1 == opt)
        {
               FLASH_CE_L;
        }
        else if(2 == opt)
        {
               FLASH_CE_H;
        }
        else
                return;
}

//flash 读数据
unsigned char readbyte_spi(void)//040 rd
{
  int k;
  unsigned char data=0x00;
  FLASH_CLK_L
  for(k=0;k<8;k++)
  {
    data=data<<1;
    FLASH_CLK_H
    if(FLASH_DOUT_R!=0)
    {
      data|=0x1;
    }
    else if(FLASH_DOUT_R == 0)
    {
      data&=~0x1;
    }
    FLASH_CLK_L
  }
  return data;
}
//flash 写数据
void writebyte_spi(unsigned char data)//040 WR
{
  int i;
  for(i=0;i<8;i++)
  {
    FLASH_CLK_L
    if((data & 0x80) == 0x80)
    {
      FLASH_DIN_H
    }
    else if((data & 0x80)== 0x0)
    {
      FLASH_DIN_L
    }
    data = data << 1;
    FLASH_CLK_H
  }
}
/************************************************************************
函数功能:        与flash通讯
入口参数:        bpLength 数据长度首地址
                                        [0][1][2][3]发送数据长度
                                        [4][5][6][7]接收数据长度
                        bpSend        发送数据结构首地址
                        bpRec        接收数据结构首地址
                        bOption1                        开始端口配置
                        bOption2                        结束端口配置
出口参数:        无
************************************************************************/
void Serialize(byte  *bpLength,byte  * bpSend, byte  * bpRec, byte bOption1,byte bOption2) 
{
        dword dwI,dwLength;
        byte bData;
//		byte a;
        ConfigureSpiMaster(bOption1);
        dwLength = *(dword  *)bpLength;/*发送数据长度*/
        for(dwI = 0; dwI < dwLength; dwI++)                     
        {	
                bData = *(bpSend + dwI);
                writebyte_spi(bData);                
        }
        if(ptrNull != (int)bpRec)
        {
                dwLength = *(dword  *)(bpLength + 4);/*接收数据长度*/
                for(dwI = 0; dwI < dwLength; dwI++)
                            *(bpRec++) = readbyte_spi();
               
        }
        ConfigureSpiMaster(bOption2);
}
/************************************************************************
函数功能:        flash写使能
入口参数:        无
出口参数:        无
************************************************************************/
void FlashWriteEnable( void )
{
        byte  bpLength[8],bpSend[1];

        *(dword  *)bpLength = 1;
        bpSend[0] = SPI_FLASH_INS_WREN;
        Serialize(bpLength, bpSend, ptrNull, ENFLASH, DISFLASH);
}
/************************************************************************
函数功能:        flash写失能
入口参数:        无
出口参数:        无
************************************************************************/
void FlashWriteDisable( void )
{
        byte  bpLength[8],bpSend[1];

        *(dword  *)bpLength = 1;
        bpSend[0] = SPI_FLASH_INS_WRDI; 
        Serialize(bpLength, bpSend, ptrNull,ENFLASH,DISFLASH);
}
/************************************************************************
函数功能:        读flash状态寄存器
入口参数:        读出数的存放地址
出口参数:        无
************************************************************************/
void FlashReadStatusRegister( byte *bpStatusRegister)
{
        byte bpLength[8],bpSend[1];

        *(dword  *)bpLength = 1; //发送的长度
        *(dword  *)(bpLength + 4) = 1;//接收的长度
        bpSend[0] = SPI_FLASH_INS_RDSR;
        Serialize(bpLength, bpSend, bpStatusRegister, ENFLASH, DISFLASH);
}

/************************************************************************
函数功能:        flash忙否
入口参数:        无
出口参数:        1/0                忙/空闲
************************************************************************/
byte IsFlashBusy()
{
        byte bSR;

        FlashReadStatusRegister(&bSR);
        if(bSR & SPI_FLASH_WIP)
                return 1;
        else
                return 0;
}

/************************************************************************
函数功能:        写flash状态寄存器
入口参数:        要写的数
出口参数:        0/1        超时/成功
************************************************************************/
byte  FlashWriteStatusRegister( byte bStatusRegister)
{
        byte  bpLength[8],bpSend[2];

        FlashWriteEnable();
        *(dword  *)bpLength = 2;
        bpSend[0] = SPI_FLASH_INS_RDSR;
        bpSend[1] = bStatusRegister;
        Serialize(bpLength, bpSend, ptrNull, ENFLASH, DISFLASH);
        g_wTimers = 40; //1s
        while(g_wTimers)
        {
                if (IsFlashBusy())
                        ;
                else
                        return 1;
        }
        return 0;
}
/************************************************************************
函数功能:        读flash
入口参数:        udAddr                首地址
                        bpElements        读出数据存放地址
                        dwLength        读的长度
出口参数:        0/1        地址无效/成功
************************************************************************/
byte FlashRead( dword dwAddr, byte  *bpRec, dword dwLength)
{
        byte  bpLength[8],bpSend[4];

        if(!(dwAddr <  FLASH_SIZE)) return 0;
        *(dword  *)bpLength = 4;    //发送的长度
        *(dword  *)(bpLength + 4) = dwLength;
        bpSend[0] = SPI_FLASH_INS_READ;
        bpSend[1] = (byte)(dwAddr>>16);
        bpSend[2] = (byte)(dwAddr>>8);
        bpSend[3] = (byte)dwAddr;
        Serialize(bpLength, bpSend, bpRec, ENFLASH, DISFLASH);
        return 1;
}
/************************************************************************
函数功能:        高速读flash
入口参数:        udAddr                首地址
                        bpElements        读出数据存放地址
                        dwLength        读的长度
出口参数:        0/1        地址无效/成功
************************************************************************/
byte FlashFastRead( dword dwAddr, byte  *bpRec, dword dwLength)
{
        byte  bpLength[8],bpSend[5];

        if(!(dwAddr <  FLASH_SIZE))
                return 0;
        *(dword  *)bpLength = 5;
        *(dword  *)(bpLength + 4) = dwLength;
        bpSend[0] = SPI_FLASH_INS_FAST_READ;
        bpSend[1] = (byte)(dwAddr>>16);
        bpSend[2] = (byte)(dwAddr>>8);
        bpSend[3] = (byte)(dwAddr);
        bpSend[4] = SPI_FLASH_INS_DUMMY;
        Serialize(bpLength, bpSend, bpRec,ENFLASH,DISFLASH);
        return 1;
}
/************************************************************************
函数功能:        页写入
入口参数:        udAddr        首地址
                        bpArray        数据首地址
                        wLen        数据长度
出口参数:        0/1/0xff        失败/成功/忙
************************************************************************/
byte FlashPageProgram( dword dwAddr, byte *bpData, word wLen)
{
        byte  bpLength[8],bpSend[4];

        if(!(dwAddr <  FLASH_SIZE)) 
                return 0;
        if(IsFlashBusy()) 
                return 0xff;
        FlashWriteEnable();
        *(dword  *)bpLength = 4;
        bpSend[0] = SPI_FLASH_INS_PP;
        bpSend[1] =(byte)(dwAddr>>16);
        bpSend[2] =(byte)(dwAddr>>8);
        bpSend[3] =(byte)dwAddr;
        Serialize(bpLength, bpSend, ptrNull, ENFLASH, 0);
        *(dword  *)bpLength = wLen;
        Serialize(bpLength, bpData, ptrNull, 0, DISFLASH);
        g_wTimers = 40;// //1s
        while(g_wTimers)
        {
                if (IsFlashBusy())
                        ;
                else
                        return 1;
        }
        return 0;
}
/************************************************************************
函数功能:        flash扇区擦除
入口参数:        扇区号
出口参数:        0/1/0xff        失败/成功/忙
************************************************************************/
byte FlashSectorErase(byte bSectorNr)
{
        byte  bpLength[8],bpSend[4];
//		byte  a;
        if(!(bSectorNr < FLASH_SECTOR_COUNT)) 
                return 0;
        if(IsFlashBusy()) 
                return 0xff;
        FlashWriteEnable();
        *(dword  *)bpLength = 4;
        bpSend[0] = SPI_FLASH_INS_SE;
        bpSend[1] = bSectorNr;
        bpSend[2] = 0;
        bpSend[3] = 0;
        Serialize(bpLength, bpSend, ptrNull,ENFLASH,DISFLASH);
        g_wTimers = 200; //5s
        while(g_wTimers)
        {
                if (IsFlashBusy()) ;
  //                      a=0;
                else
                        return 1;
        }
        return 0;
}
/************************************************************************
函数功能:        flash整片擦除
入口参数:        无
出口参数:        0/1/0xff        失败/成功/忙        
************************************************************************/
byte Flash_Erase(void)
{
        byte  bpLength[8],bpSend[4];

        if(IsFlashBusy()) 
                return 0xff;
        FlashWriteEnable();
        bpSend[0] = SPI_FLASH_INS_BE; 
        *(dword  *)bpLength = 1;
        Serialize(bpLength, bpSend, ptrNull,ENFLASH,DISFLASH);
        g_wTimers = 4000; //100s
        while(g_wTimers)
        {
                if (IsFlashBusy())
                        ;
                else
                        return 1;
        }
        return 0;
}
/************************************************************************
函数功能:        写flash
入口参数:        dwAddr                首地址
                        bpArray                数据首地址
                        dwLength        数据长度
出口参数:        0/1/0xff        失败/成功/忙
************************************************************************/
byte FlashProgram(dword dwAddr, byte  *bpData, dword dwLength)
{
        word wMargin;
        word wPageCount, wRemainder;
        byte bTemp;

        if(!(dwAddr <  FLASH_SIZE))  //地址大于FLASH_SIZE
                return 0;
        if(dwAddr + dwLength > FLASH_SIZE)//地址+长度大于FLASH_SIZE
                return 0; 

		
        wMargin = (byte)(~dwAddr) + 1; //剩余扇区空间
        if(dwLength > wMargin) //长度大于剩余扇区，需换扇区
        {
                bTemp = FlashPageProgram(dwAddr, bpData, wMargin); //烧写剩余的扇区
                if(1 != bTemp) //烧写正确
                        return 0;
                dwLength -= wMargin; //减去不满256字节的数据
                bpData += wMargin;
                dwAddr += wMargin;
                wPageCount = dwLength / FLASH_WRITE_BUFFER_SIZE;
                wRemainder = dwLength % FLASH_WRITE_BUFFER_SIZE;
                while(wPageCount--)
                {
                        bTemp = FlashPageProgram(dwAddr, bpData, FLASH_WRITE_BUFFER_SIZE);
                        if(1 != bTemp) 
                                return 0;
                        bpData += FLASH_WRITE_BUFFER_SIZE;
                        dwAddr += FLASH_WRITE_BUFFER_SIZE;
                };
                return FlashPageProgram(dwAddr, bpData, wRemainder);
        }
        else //如果小于256扇区空间 ，直接烧写
        {
                return FlashPageProgram(dwAddr, bpData, dwLength);
        }
}


//写SPI FLASH 
//在指定地址开始写入指定长度的数据
//该函数带擦除操作!
//pBuffer:数据存储区
//WriteAddr:开始写入的地址(24bit)                                      
//NumByteToWrite:要写入的字节数(最大65535)  
u8 SPI_FLASH_BUFFER[FLASH_WRITE_BUFFER_SIZE];       
void SPI_Flash_Write(u8* pBuffer,u32 WriteAddr,u16 NumByteToWrite)  
{
       u32 secpos;
       u16 secoff;
       u16 secremain;         
       u16 i;   
       u8 * SPI_FLASH_BUF;        
       SPI_FLASH_BUF=SPI_FLASH_BUFFER;     
       secpos=WriteAddr/FLASH_WRITE_BUFFER_SIZE;//扇区地址 0~511 for w25x16
       secoff=WriteAddr%FLASH_WRITE_BUFFER_SIZE;//在扇区内的偏移
       secremain=FLASH_WRITE_BUFFER_SIZE-secoff;//扇区剩余空间大小  

      if(NumByteToWrite<=secremain)secremain=NumByteToWrite;
       while(1)
       {    
             // SPI_Flash_Read(SPI_FLASH_BUF,secpos*FLASH_WRITE_BUFFER_SIZE,FLASH_WRITE_BUFFER_SIZE);//读出整个扇区的内容
              Flash_Rw_Func(0,secpos*FLASH_WRITE_BUFFER_SIZE,SPI_FLASH_BUF, FLASH_WRITE_BUFFER_SIZE);
             for(i=0;i<secremain;i++)//校验数据
              {
                     if(SPI_FLASH_BUF[secoff+i]!=0XFF)break;//需要擦除          
              }
            
              if(i<secremain)//需要擦除
              {
                     FlashSectorErase(secpos);//擦除这个扇区
                     for(i=0;i<secremain;i++)          //复制
                     {
                            SPI_FLASH_BUF[i+secoff]=pBuffer[i];      
                     }
			//    Flash_Rw_Func(1,secpos*FLASH_WRITE_BUFFER_SIZE,SPI_FLASH_BUF, FLASH_WRITE_BUFFER_SIZE);
				FlashPageProgram(secpos*FLASH_WRITE_BUFFER_SIZE, SPI_FLASH_BUF, FLASH_WRITE_BUFFER_SIZE);
                 //    SPI_Flash_Write_NoCheck(SPI_FLASH_BUF,secpos*4096,4096);
            //写入整个扇区 
              }
			  else 
		     //  SPI_Flash_Write_NoCheck(pBuffer,WriteAddr,secremain);
			  FlashPageProgram(secpos*FLASH_WRITE_BUFFER_SIZE, SPI_FLASH_BUF, secremain);

           
          //写已经擦除了的,直接写入扇区剩余区间.  
              if(NumByteToWrite==secremain)
			        break;//写入结束了
              else//写入未结束
              {
                     secpos++;//扇区地址增1
                     secoff=0;//偏移位置为0
                   pBuffer+=secremain;  //指针偏移
                     WriteAddr+=secremain;//写地址偏移     
                   NumByteToWrite-=secremain;                           //字节数递减
                     if(NumByteToWrite>4096)
					          secremain=4096;        //下一个扇区还是写不完
                     else 
					   secremain=NumByteToWrite;                      //下一个扇区可以写完了
              }    
       };   
}
/************************************************************************
函数功能:        Flash读写处理函数
入口参数:        bRw                :        0/1        读/写
                        dwAddr        :        Flash逻辑地址
                        bpData        :        数据首地址
                        wLen        :        读写长度
出口参数:        0/1/0xff        失败/成功/忙
************************************************************************/
byte Flash_Rw_Func(byte bRw,dword dwAddr,byte  *bpData,word wLen)
{
        byte  bTemp;
        if (bRw)
        {
                bTemp = FlashProgram(dwAddr, bpData, wLen);
        }
        else
        {
                bTemp = FlashRead(dwAddr, bpData, wLen);
        }
        return bTemp;
}

/* 
void test_main(void)
{
       unsigned char time=0 ; 
        word wLen = 200;
//		Flash_Erase();//整片擦除

 //   FlashPageProgram(0, &bpData[0], FLASH_WRITE_BUFFER_SIZE);
//	FlashPageProgram(256, &bpData[256], FLASH_WRITE_BUFFER_SIZE);
 //   FlashPageProgram(512,&bpData[0],100);
	 
		Flash_Rw_Func(0,0,RDData, 4096);
}
  */

  

