
#include "InputHandle.h"
#include "dvNVRAM.h"
#include "sii_api.h"
#include "si_timer.h"
#include "appUserInterface.h"
#include "InputReceiveEvent.h"
#include "Edid.h"

#define Timing1   54
#define Timing2    72
#define Timing3   90
#define Timing4    108
#define Checksum    127
#define NumberOffset   130
#define GeneralFormat   132

extern BYTE OutputEdidData[MAX_OUT][256];

const uint8_t EDID_720P_2D_BYPASS[EDID_TABLE_LEN]=			// 1
{
       0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0x00, 0x90, 0x0f, 0x00, 0x00, 0x00,
	0x01, 0x12, 0x01, 0x03, 0x80, 0xa0, 0x5a, 0x78, 0x0a, 0x3c, 0xe0, 0xa0, 0x57, 0x47, 0x98, 0x27,
	0x12, 0x4c, 0x4c, 0x21, 0x08, 0x00, 0x31, 0x40, 0x45, 0x40, 0x61, 0x40, 0x81, 0x80, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xce, 0x22, 0x00, 0xbc, 0x52, 0xd0, 0x1e, 0x20, 0xb8, 0x28,
	0x55, 0x40, 0x10, 0x09, 0x00, 0x00, 0x00, 0x1e, 0x28, 0x3c, 0x80, 0xa0, 0x70, 0xb0, 0x23, 0x40,
	0x30, 0x20, 0x36, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x4c,
	0x43, 0x44, 0x54, 0x56, 0x31, 0x36, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfd,
	0x00, 0x30, 0x3e, 0x0e, 0x44, 0x0f, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xa3,
	0x02, 0x03, 0x23, 0x70, 0x4f, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13,
	0x14, 0x15, 0x16, 0x1f, 0x23, 0x09, 0x07, 0x07, 0x83, 0x01, 0x00, 0x00, 0x66, 0x03, 0x0c, 0x00,
	0x20, 0x00, 0x80, 0x01, 0x1d, 0x80, 0xd0, 0x72, 0x1c, 0x16, 0x20, 0x10, 0x2c, 0x25, 0x80, 0x40,
	0x84, 0x63, 0x00, 0x00, 0x9e, 0x01, 0x1d, 0x80, 0x18, 0x71, 0x1c, 0x16, 0x20, 0x58, 0x2c, 0x25,
	0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x98, 0x01, 0x1d, 0x00, 0xbc, 0x52, 0xd0, 0x1e, 0x20, 0xb8,
	0x28, 0x55, 0x40, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1e, 0x02, 0x3a, 0x80, 0xd0, 0x72, 0x38, 0x2d,
	0x40, 0x10, 0x2c, 0x45, 0x80, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0
};

const uint8_t EDID_720P_3D_BYPASS[EDID_TABLE_LEN]=			// 2
{
       0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0x00, 0x90, 0x0f, 0x00, 0x00, 0x00,
	0x01, 0x12, 0x01, 0x03, 0x80, 0xa0, 0x5a, 0x78, 0x0a, 0x3c, 0xe0, 0xa0, 0x57, 0x47, 0x98, 0x27,
	0x12, 0x4c, 0x4c, 0x21, 0x08, 0x00, 0x31, 0x40, 0x45, 0x40, 0x61, 0x40, 0x81, 0x80, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xce, 0x22, 0x00, 0xbc, 0x52, 0xd0, 0x1e, 0x20, 0xb8, 0x28,
	0x55, 0x40, 0x10, 0x09, 0x00, 0x00, 0x00, 0x1e, 0x28, 0x3c, 0x80, 0xa0, 0x70, 0xb0, 0x23, 0x40,
	0x30, 0x20, 0x36, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x4c,
	0x43, 0x44, 0x54, 0x56, 0x31, 0x36, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfd,
	0x00, 0x30, 0x3e, 0x0e, 0x44, 0x0f, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xa3,
	0x02, 0x03, 0x31, 0x70, 0x4f, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13,
	0x14, 0x15, 0x16, 0x1f, 0x23, 0x09, 0x07, 0x07, 0x83, 0x01, 0x00, 0x00, 0x74, 0x03, 0x0c, 0x00,
	0x20, 0x00, 0xb9, 0x2d, 0x2f, 0x80, 0x0a, 0x01, 0x40, 0x00, 0x7f, 0x20, 0x30, 0x70, 0x80, 0x90,
	0x76, 0x01, 0x1d, 0x80, 0xd0, 0x72, 0x1c, 0x16, 0x20, 0x10, 0x2c, 0x25, 0x80, 0x40, 0x84, 0x63,
	0x00, 0x00, 0x9e, 0x01, 0x1d, 0x80, 0x18, 0x71, 0x1c, 0x16, 0x20, 0x58, 0x2c, 0x25, 0x00, 0x40,
	0x84, 0x63, 0x00, 0x00, 0x98, 0x01, 0x1d, 0x00, 0xbc, 0x52, 0xd0, 0x1e, 0x20, 0xb8, 0x28, 0x55,
	0x40, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1e, 0x02, 0x3a, 0x80, 0xd0, 0x72, 0x38, 0x2d, 0x40, 0x10,
	0x2c, 0x45, 0x80, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaf
};

const uint8_t EDID_1080P_2D_BYPASS[EDID_TABLE_LEN]=			// 3
{
       0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0x00, 0x90, 0x0f, 0x00, 0x00, 0x00,
	0x01, 0x12, 0x01, 0x03, 0x80, 0xa0, 0x5a, 0x78, 0x0a, 0x01, 0xc1, 0xa0, 0x57, 0x47, 0x98, 0x27,
	0x12, 0x4c, 0x4c, 0x21, 0x08, 0x00, 0x31, 0x40, 0x45, 0x40, 0x61, 0x40, 0x81, 0x80, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3a, 0x80, 0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c,
	0x45, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1e, 0x28, 0x3c, 0x80, 0xa0, 0x70, 0xb0, 0x23, 0x40,
	0x30, 0x20, 0x36, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x4c,
	0x43, 0x44, 0x54, 0x56, 0x31, 0x36, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfd,
	0x00, 0x30, 0x3e, 0x0e, 0x44, 0x0f, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xbd,
	0x02, 0x03, 0x23, 0x70, 0x4f, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13,
	0x14, 0x15, 0x16, 0x1f, 0x23, 0x09, 0x07, 0x07, 0x83, 0x01, 0x00, 0x00, 0x66, 0x03, 0x0c, 0x00,
	0x20, 0x00, 0x80, 0x01, 0x1d, 0x80, 0xd0, 0x72, 0x1c, 0x16, 0x20, 0x10, 0x2c, 0x25, 0x80, 0x40,
	0x84, 0x63, 0x00, 0x00, 0x9e, 0x01, 0x1d, 0x80, 0x18, 0x71, 0x1c, 0x16, 0x20, 0x58, 0x2c, 0x25,
	0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x98, 0x01, 0x1d, 0x00, 0xbc, 0x52, 0xd0, 0x1e, 0x20, 0xb8,
	0x28, 0x55, 0x40, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1e, 0x02, 0x3a, 0x80, 0xd0, 0x72, 0x38, 0x2d,
	0x40, 0x10, 0x2c, 0x45, 0x80, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0
};

const uint8_t EDID_1080P_3D_BYPASS[EDID_TABLE_LEN]=			// 4
{
       0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0x00, 0x90, 0x0f, 0x00, 0x00, 0x00,
	0x01, 0x12, 0x01, 0x03, 0x80, 0xa0, 0x5a, 0x78, 0x0a, 0x01, 0xc1, 0xa0, 0x57, 0x47, 0x98, 0x27,
	0x12, 0x4c, 0x4c, 0x21, 0x08, 0x00, 0x31, 0x40, 0x45, 0x40, 0x61, 0x40, 0x81, 0x80, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3a, 0x80, 0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c,
	0x45, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1e, 0x28, 0x3c, 0x80, 0xa0, 0x70, 0xb0, 0x23, 0x40,
	0x30, 0x20, 0x36, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x4c,
	0x43, 0x44, 0x54, 0x56, 0x31, 0x36, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfd,
	0x00, 0x30, 0x3e, 0x0e, 0x44, 0x0f, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0xbd,
	0x02, 0x03, 0x31, 0x70, 0x4f, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x10, 0x11, 0x12, 0x13,
	0x14, 0x15, 0x16, 0x1f, 0x23, 0x09, 0x07, 0x07, 0x83, 0x01, 0x00, 0x00, 0x74, 0x03, 0x0c, 0x00,
	0x20, 0x00, 0xb9, 0x2d, 0x2f, 0x80, 0x0a, 0x01, 0x40, 0x00, 0x7f, 0x20, 0x30, 0x70, 0x80, 0x90,
	0x76, 0x01, 0x1d, 0x80, 0xd0, 0x72, 0x1c, 0x16, 0x20, 0x10, 0x2c, 0x25, 0x80, 0x40, 0x84, 0x63,
	0x00, 0x00, 0x9e, 0x01, 0x1d, 0x80, 0x18, 0x71, 0x1c, 0x16, 0x20, 0x58, 0x2c, 0x25, 0x00, 0x40,
	0x84, 0x63, 0x00, 0x00, 0x98, 0x01, 0x1d, 0x00, 0xbc, 0x52, 0xd0, 0x1e, 0x20, 0xb8, 0x28, 0x55,
	0x40, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1e, 0x02, 0x3a, 0x80, 0xd0, 0x72, 0x38, 0x2d, 0x40, 0x10,
	0x2c, 0x45, 0x80, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xaf
};


const uint8_t EDID_4K_30HZ_BYPASS[EDID_TABLE_LEN]=			// 5
{
       0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0x00, 0x90, 0x0f, 0x00, 0x00, 0x00,
	0x04, 0x18, 0x01, 0x03, 0x80, 0x3e, 0x22, 0x78, 0xea, 0xbe, 0x30, 0xa2, 0x57, 0x4f, 0xa2, 0x28,
	0x0f, 0x50, 0x54, 0xa5, 0x4b, 0x00, 0x71, 0x4f, 0x81, 0x00, 0x81, 0x80, 0xa9, 0x40, 0xb3, 0x00,
	0xd1, 0xc0, 0xd1, 0x00, 0x01, 0x01, 0x04, 0x74, 0x00, 0x30, 0xf2, 0x70, 0x5a, 0x80, 0xb0, 0x58,
	0x8a, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0xff, 0x00, 0x57, 0x4a, 0x4a,
	0x47, 0x52, 0x34, 0x31, 0x49, 0x41, 0x32, 0x31, 0x4d, 0x0a, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x4c,
	0x43, 0x44, 0x54, 0x56, 0x31, 0x36, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfd,
	0x00, 0x18, 0x55, 0x1f, 0x72, 0x1e, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x4d,
	0x02, 0x03, 0x2d, 0xf1, 0x52, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x90, 0x11, 0x12, 0x13,
	0x14, 0x15, 0x16, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x09, 0x1f, 0x07, 0x83, 0x01, 0x00, 0x00, 0x6d,
	0x03, 0x0c, 0x00, 0x10, 0x00, 0x00, 0x3c, 0x20, 0x00, 0x60, 0x03, 0x02, 0x01, 0x02, 0x3a, 0x80,
	0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c, 0x45, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00, 0x1e, 0x01,
	0x1d, 0x80, 0x18, 0x71, 0x1c, 0x16, 0x20, 0x58, 0x2c, 0x25, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00,
	0x9e, 0x01, 0x1d, 0x00, 0x72, 0x51, 0xd0, 0x1e, 0x20, 0x6e, 0x28, 0x55, 0x00, 0x6d, 0x55, 0x21,
	0x00, 0x00, 0x1e, 0x8c, 0x0a, 0xd0, 0x8a, 0x20, 0xe0, 0x2d, 0x10, 0x10, 0x3e, 0x96, 0x00, 0x6d,
	0x55, 0x21, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86
};


const uint8_t EDID_4K_30HZ_2CH[EDID_TABLE_LEN]=				// 6
{
       0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0x00, 0x90, 0x0f, 0x00, 0x00, 0x00,
	0x04, 0x18, 0x01, 0x03, 0x80, 0x3e, 0x22, 0x78, 0xea, 0xbe, 0x30, 0xa2, 0x57, 0x4f, 0xa2, 0x28,
	0x0f, 0x50, 0x54, 0xa5, 0x4b, 0x00, 0x71, 0x4f, 0x81, 0x00, 0x81, 0x80, 0xa9, 0x40, 0xb3, 0x00,
	0xd1, 0xc0, 0xd1, 0x00, 0x01, 0x01, 0x04, 0x74, 0x00, 0x30, 0xf2, 0x70, 0x5a, 0x80, 0xb0, 0x58,
	0x8a, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0xff, 0x00, 0x57, 0x4a, 0x4a,
	0x47, 0x52, 0x34, 0x31, 0x49, 0x41, 0x32, 0x31, 0x4d, 0x0a, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x4c,
	0x43, 0x44, 0x54, 0x56, 0x31, 0x36, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfd,
	0x00, 0x18, 0x55, 0x1f, 0x72, 0x1e, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x4d,
	0x02, 0x03, 0x2d, 0xf1, 0x52, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x90, 0x11, 0x12, 0x13,
	0x14, 0x15, 0x16, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x09, 0x1f, 0x07, 0x83, 0x01, 0x00, 0x00, 0x6d,
	0x03, 0x0c, 0x00, 0x10, 0x00, 0x00, 0x3c, 0x20, 0x00, 0x60, 0x03, 0x02, 0x01, 0x02, 0x3a, 0x80,
	0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c, 0x45, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00, 0x1e, 0x01,
	0x1d, 0x80, 0x18, 0x71, 0x1c, 0x16, 0x20, 0x58, 0x2c, 0x25, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00,
	0x9e, 0x01, 0x1d, 0x00, 0x72, 0x51, 0xd0, 0x1e, 0x20, 0x6e, 0x28, 0x55, 0x00, 0x6d, 0x55, 0x21,
	0x00, 0x00, 0x1e, 0x8c, 0x0a, 0xd0, 0x8a, 0x20, 0xe0, 0x2d, 0x10, 0x10, 0x3e, 0x96, 0x00, 0x6d,
	0x55, 0x21, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86
};


const uint8_t EDID_4K_30HZ_8CH[EDID_TABLE_LEN]=				// 7
{
       0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0x00, 0x90, 0x0f, 0x00, 0x00, 0x00,
	0x04, 0x18, 0x01, 0x03, 0x80, 0x3e, 0x22, 0x78, 0xea, 0xbe, 0x30, 0xa2, 0x57, 0x4f, 0xa2, 0x28,
	0x0f, 0x50, 0x54, 0xa5, 0x4b, 0x00, 0x71, 0x4f, 0x81, 0x00, 0x81, 0x80, 0xa9, 0x40, 0xb3, 0x00,
	0xd1, 0xc0, 0xd1, 0x00, 0x01, 0x01, 0x04, 0x74, 0x00, 0x30, 0xf2, 0x70, 0x5a, 0x80, 0xb0, 0x58,
	0x8a, 0x00, 0x40, 0x84, 0x63, 0x00, 0x00, 0x1e, 0x00, 0x00, 0x00, 0xff, 0x00, 0x57, 0x4a, 0x4a,
	0x47, 0x52, 0x34, 0x31, 0x49, 0x41, 0x32, 0x31, 0x4d, 0x0a, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x4c,
	0x43, 0x44, 0x54, 0x56, 0x31, 0x36, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfd,
	0x00, 0x18, 0x55, 0x1f, 0x72, 0x1e, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x4d,
	0x02, 0x03, 0x2d, 0xf1, 0x52, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x90, 0x11, 0x12, 0x13,
	0x14, 0x15, 0x16, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x0f, 0x1f, 0x07, 0x83, 0x01, 0x00, 0x00, 0x6d,
	0x03, 0x0c, 0x00, 0x10, 0x00, 0x00, 0x3c, 0x20, 0x00, 0x60, 0x03, 0x02, 0x01, 0x02, 0x3a, 0x80,
	0x18, 0x71, 0x38, 0x2d, 0x40, 0x58, 0x2c, 0x45, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00, 0x1e, 0x01,
	0x1d, 0x80, 0x18, 0x71, 0x1c, 0x16, 0x20, 0x58, 0x2c, 0x25, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00,
	0x9e, 0x01, 0x1d, 0x00, 0x72, 0x51, 0xd0, 0x1e, 0x20, 0x6e, 0x28, 0x55, 0x00, 0x6d, 0x55, 0x21,
	0x00, 0x00, 0x1e, 0x8c, 0x0a, 0xd0, 0x8a, 0x20, 0xe0, 0x2d, 0x10, 0x10, 0x3e, 0x96, 0x00, 0x6d,
	0x55, 0x21, 0x00, 0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80
};


const uint8_t EDID_4K_60HZ_420_BYPASS[EDID_TABLE_LEN]=			// 8
{
0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x7F,0xFF,0x00,0x90,0x9D,0x0D,0x00,0x00,
0x03,0x1A,0x01,0x03,0x80,0x3E,0x22,0x78,0x2A,0xBE,0x30,0xA2,0x57,0x4F,0xA2,0x28,
0x0F,0x50,0x54,0xBF,0xEF,0x00,0xD1,0xC0,0xB3,0x00,0x95,0x00,0x81,0x80,0x81,0x40,
0x81,0xC0,0x01,0x01,0x01,0x01,0x50,0xD0,0x00,0xA0,0xF0,0x70,0x3E,0x80,0x30,0x20,
0x35,0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0xB4,0x66,0x00,0xA0,0xF0,0x70,0x1F,0x80,
0x30,0x20,0x35,0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0x00,0x00,0x00,0xFC,0x00,0x4C,
0x43,0x44,0x54,0x56,0x31,0x36,0x0A,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFD,
0x00,0x17,0x50,0x1E,0x8C,0x3C,0x00,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x01,0x30,
0x02,0x03,0x33,0xF1,0x4C,0x90,0x04,0x03,0x1F,0x13,0x01,0x12,0x5D,0x5E,0x5F,0x60,
0x61,0x23,0x09,0x07,0x07,0x83,0x01,0x00,0x00,0x6D,0x03,0x0C,0x00,0x10,0x00,0x39,
0x78,0x20,0x00,0x60,0x01,0x02,0x03,0x67,0xD8,0x5D,0xC4,0x01,0x78,0x80,0x03,0xE3,
0x0F,0x00,0x0C,0x01,0x1D,0x00,0x72,0x51,0xD0,0x1E,0x20,0x6E,0x28,0x55,0x00,0x6D,
0x55,0x21,0x00,0x00,0x1E,0x4D,0x6C,0x80,0xA0,0x70,0x70,0x3E,0x80,0x30,0x20,0x3A,
0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0xA3,0x66,0x00,0xA0,0xF0,0x70,0x1F,0x80,0x30,
0x20,0x35,0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF6

};

#if 0  //before
const uint8_t EDID_4K_60HZ_420_8CH[EDID_TABLE_LEN]=				// 9
{
       0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0x00, 0x90, 0x9d, 0x0d, 0x00, 0x00,
	0x03, 0x1a, 0x01, 0x03, 0x80, 0x3e, 0x22, 0x78, 0x2a, 0xbe, 0x30, 0xa2, 0x57, 0x4f, 0xa2, 0x28,
	0x0f, 0x50, 0x54, 0xbf, 0xef, 0x00, 0xd1, 0xc0, 0xb3, 0x00, 0x95, 0x00, 0x81, 0x80, 0x81, 0x40,
	0x81, 0xc0, 0x01, 0x01, 0x01, 0x01, 0x4d, 0xd0, 0x00, 0xa0, 0xf0, 0x70, 0x3e, 0x80, 0x30, 0x20,
	0x35, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00, 0x1a, 0xa3, 0x66, 0x00, 0xa0, 0xf0, 0x70, 0x1f, 0x80,
	0x30, 0x20, 0x35, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x4c,
	0x43, 0x44, 0x54, 0x56, 0x31, 0x36, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfd,
	0x00, 0x17, 0x50, 0x1e, 0x8c, 0x3c, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x44,
	0x02, 0x03, 0x33, 0xf1, 0x4c, 0x90, 0x04, 0x03, 0x1f, 0x13, 0x01, 0x12, 0x5d, 0x5e, 0x5f, 0x60,
	0x61, 0x23, 0x0f, 0x07, 0x07, 0x83, 0x01, 0x00, 0x00, 0x6d, 0x03, 0x0c, 0x00, 0x10, 0x00, 0x39,
	0x78, 0x20, 0x00, 0x60, 0x01, 0x02, 0x03, 0x67, 0xd8, 0x5d, 0xc4, 0x01, 0x78, 0x80, 0x03, 0xe3,
	0x0f, 0x00, 0x0c, 0x01, 0x1d, 0x00, 0x72, 0x51, 0xd0, 0x1e, 0x20, 0x6e, 0x28, 0x55, 0x00, 0x6d,
	0x55, 0x21, 0x00, 0x00, 0x1e, 0x4d, 0x6c, 0x80, 0xa0, 0x70, 0x70, 0x3e, 0x80, 0x30, 0x20, 0x3a,
	0x00, 0x6d, 0x55, 0x21, 0x00, 0x00, 0x1a, 0xa3, 0x66, 0x00, 0xa0, 0xf0, 0x70, 0x1f, 0x80, 0x30,
	0x20, 0x35, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0
};
#endif

const uint8_t EDID_4K_60HZ_420_8CH[EDID_TABLE_LEN]={
0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x7F,0xFF,0x00,0x90,0x9D,0x0D,0x00,0x00,
0x03,0x1A,0x01,0x03,0x80,0x3E,0x22,0x78,0x2A,0xBE,0x30,0xA2,0x57,0x4F,0xA2,0x28,
0x0F,0x50,0x54,0xBF,0xEF,0x00,0xD1,0xC0,0xB3,0x00,0x95,0x00,0x81,0x80,0x81,0x40,
0x81,0xC0,0x01,0x01,0x01,0x01,0x50,0xD0,0x00,0xA0,0xF0,0x70,0x3E,0x80,0x30,0x20,
0x35,0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0xB4,0x66,0x00,0xA0,0xF0,0x70,0x1F,0x80,
0x30,0x20,0x35,0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0x00,0x00,0x00,0xFC,0x00,0x4C,
0x43,0x44,0x54,0x56,0x31,0x36,0x0A,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFD,
0x00,0x17,0x50,0x1E,0x8C,0x3C,0x00,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x01,0x30,
0x02,0x03,0x33,0xF1,0x4C,0x90,0x04,0x03,0x1F,0x13,0x01,0x12,0x5D,0x5E,0x5F,0x60,
0x61,0x23,0x0F,0x07,0x07,0x83,0x01,0x00,0x00,0x6D,0x03,0x0C,0x00,0x10,0x00,0x39,
0x78,0x20,0x00,0x60,0x01,0x02,0x03,0x67,0xD8,0x5D,0xC4,0x01,0x78,0x80,0x03,0xE3,
0x0F,0x00,0x0C,0x01,0x1D,0x00,0x72,0x51,0xD0,0x1E,0x20,0x6E,0x28,0x55,0x00,0x6D,
0x55,0x21,0x00,0x00,0x1E,0x4D,0x6C,0x80,0xA0,0x70,0x70,0x3E,0x80,0x30,0x20,0x3A,
0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0xA3,0x66,0x00,0xA0,0xF0,0x70,0x1F,0x80,0x30,
0x20,0x35,0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0
};
#if 0   //mine
const uint8_t EDID_4K_60HZ_420_BYPASS[EDID_TABLE_LEN]=
{
0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x7F,0xFF,0x00,0x90,0x0F,0x00,0x00,0x00,
0x01,0x1B,0x01,0x03,0x80,0x50,0x2D,0x78,0x0A,0xC1,0xB0,0xA3,0x54,0x4C,0x99,0x26,
0x0F,0x50,0x54,0x20,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x04,0x74,0x00,0x30,0xF2,0x70,0x5A,0x80,0xB0,0x58,
0x8A,0x00,0x50,0x1D,0x74,0x00,0x00,0x1E,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,
0x58,0x2C,0x45,0x00,0x20,0xC2,0x31,0x00,0x00,0x1E,0x00,0x00,0x00,0xFD,0x00,0x18,
0x4B,0x1A,0x51,0x1E,0x00,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFC,
0x00,0x4C,0x43,0x44,0x54,0x56,0x31,0x36,0x0A,0x20,0x20,0x20,0x20,0x20,0x01,0x5D,
0x02,0x03,0x42,0x70,0x51,0x5F,0x5E,0x5D,0x64,0x63,0x62,0x10,0x1F,0x22,0x21,0x20,
0x05,0x14,0x04,0x13,0x12,0x03,0x32,0x0F,0x7F,0x07,0x15,0x07,0x50,0x3D,0x0E,0xC0,
0x57,0x06,0x01,0x5F,0x7E,0x01,0x67,0x1E,0x00,0x83,0x01,0x00,0x00,0x67,0x03,0x0C,
0x00,0x10,0x00,0xB8,0x3C,0xE2,0x00,0x0F,0xE3,0x05,0x03,0x01,0xE5,0x0E,0x61,0x60,
0x66,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x85


};



const uint8_t EDID_4K_60HZ_420_8CH[EDID_TABLE_LEN]=				// 9
{
0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x7F,0xFF,0x00,0x90,0x0F,0x00,0x00,0x00,
0x01,0x1B,0x01,0x03,0x80,0x50,0x2D,0x78,0x0A,0xC1,0xB0,0xA3,0x54,0x4C,0x99,0x26,
0x0F,0x50,0x54,0x20,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x04,0x74,0x00,0x30,0xF2,0x70,0x5A,0x80,0xB0,0x58,
0x8A,0x00,0x50,0x1D,0x74,0x00,0x00,0x1E,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,
0x58,0x2C,0x45,0x00,0x20,0xC2,0x31,0x00,0x00,0x1E,0x00,0x00,0x00,0xFD,0x00,0x18,
0x4B,0x1A,0x51,0x1E,0x00,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFC,
0x00,0x4C,0x43,0x44,0x54,0x56,0x31,0x36,0x0A,0x20,0x20,0x20,0x20,0x20,0x01,0x5D,
0x02,0x03,0x42,0x70,0x51,0x5F,0x5E,0x5D,0x64,0x63,0x62,0x10,0x1F,0x22,0x21,0x20,
0x05,0x14,0x04,0x13,0x12,0x03,0x32,0x0F,0x7F,0x07,0x15,0x07,0x50,0x3D,0x0E,0xC0,
0x57,0x06,0x01,0x5F,0x7E,0x01,0x67,0x1E,0x00,0x83,0x01,0x00,0x00,0x67,0x03,0x0C,
0x00,0x10,0x00,0xB8,0x3C,0xE2,0x00,0x0F,0xE3,0x05,0x03,0x01,0xE5,0x0E,0x61,0x60,
0x66,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x85

};

#endif



const uint8_t EDID_4K_60HZ_444_BYPASS[EDID_TABLE_LEN]=			// 10
{
0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x7F,0xFF,0x00,0x90,0x9D,0x0D,0x00,0x00,
0x03,0x1A,0x01,0x03,0x80,0x3E,0x22,0x78,0x2A,0xBE,0x30,0xA2,0x57,0x4F,0xA2,0x28,
0x0F,0x50,0x54,0xBF,0xEF,0x00,0xD1,0xC0,0xB3,0x00,0x95,0x00,0x81,0x80,0x81,0x40,
0x81,0xC0,0x01,0x01,0x01,0x01,0x50,0xD0,0x00,0xA0,0xF0,0x70,0x3E,0x80,0x30,0x20,
0x35,0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0xB4,0x66,0x00,0xA0,0xF0,0x70,0x1F,0x80,
0x30,0x20,0x35,0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0x00,0x00,0x00,0xFC,0x00,0x4C,
0x43,0x44,0x54,0x56,0x31,0x36,0x0A,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFD,
0x00,0x17,0x50,0x1E,0x8C,0x3C,0x00,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x01,0x30,
0x02,0x03,0x33,0xF1,0x4C,0x90,0x04,0x03,0x1F,0x13,0x01,0x12,0x5D,0x5E,0x5F,0x60,
0x61,0x23,0x09,0x07,0x07,0x83,0x01,0x00,0x00,0x6D,0x03,0x0C,0x00,0x10,0x00,0x39,
0x78,0x20,0x00,0x60,0x01,0x02,0x03,0x67,0xD8,0x5D,0xC4,0x01,0x78,0x80,0x03,0xE3,
0x0F,0x00,0x0C,0x01,0x1D,0x00,0x72,0x51,0xD0,0x1E,0x20,0x6E,0x28,0x55,0x00,0x6D,
0x55,0x21,0x00,0x00,0x1E,0x4D,0x6C,0x80,0xA0,0x70,0x70,0x3E,0x80,0x30,0x20,0x3A,
0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0xA3,0x66,0x00,0xA0,0xF0,0x70,0x1F,0x80,0x30,
0x20,0x35,0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF6
};

#if 0 //before
const uint8_t EDID_4K_60HZ_444_8CH[EDID_TABLE_LEN]=				// 11
{
       0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x7f, 0xff, 0x00, 0x90, 0x9d, 0x0d, 0x00, 0x00,
	0x03, 0x1a, 0x01, 0x03, 0x80, 0x3e, 0x22, 0x78, 0x2a, 0xbe, 0x30, 0xa2, 0x57, 0x4f, 0xa2, 0x28,
	0x0f, 0x50, 0x54, 0xbf, 0xef, 0x00, 0xd1, 0xc0, 0xb3, 0x00, 0x95, 0x00, 0x81, 0x80, 0x81, 0x40,
	0x81, 0xc0, 0x01, 0x01, 0x01, 0x01, 0x4d, 0xd0, 0x00, 0xa0, 0xf0, 0x70, 0x3e, 0x80, 0x30, 0x20,
	0x35, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00, 0x1a, 0xa3, 0x66, 0x00, 0xa0, 0xf0, 0x70, 0x1f, 0x80,
	0x30, 0x20, 0x35, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0xfc, 0x00, 0x4c,
	0x43, 0x44, 0x54, 0x56, 0x31, 0x36, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0xfd,
	0x00, 0x17, 0x50, 0x1e, 0x8c, 0x3c, 0x00, 0x0a, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x44,
	0x02, 0x03, 0x33, 0xf1, 0x4c, 0x90, 0x04, 0x03, 0x1f, 0x13, 0x01, 0x12, 0x5d, 0x5e, 0x5f, 0x60,
	0x61, 0x23, 0x0f, 0x07, 0x07, 0x83, 0x01, 0x00, 0x00, 0x6d, 0x03, 0x0c, 0x00, 0x10, 0x00, 0x39,
	0x78, 0x20, 0x00, 0x60, 0x01, 0x02, 0x03, 0x67, 0xd8, 0x5d, 0xc4, 0x01, 0x78, 0x80, 0x03, 0xe3,
	0x0f, 0x00, 0x0c, 0x01, 0x1d, 0x00, 0x72, 0x51, 0xd0, 0x1e, 0x20, 0x6e, 0x28, 0x55, 0x00, 0x6d,
	0x55, 0x21, 0x00, 0x00, 0x1e, 0x4d, 0x6c, 0x80, 0xa0, 0x70, 0x70, 0x3e, 0x80, 0x30, 0x20, 0x3a,
	0x00, 0x6d, 0x55, 0x21, 0x00, 0x00, 0x1a, 0xa3, 0x66, 0x00, 0xa0, 0xf0, 0x70, 0x1f, 0x80, 0x30,
	0x20, 0x35, 0x00, 0x6d, 0x55, 0x21, 0x00, 0x00, 0x1a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0
};
#endif



const uint8_t EDID_4K_60HZ_444_8CH[EDID_TABLE_LEN]={
	0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x7F,0xFF,0x00,0x90,0x9D,0x0D,0x00,0x00,
	0x03,0x1A,0x01,0x03,0x80,0x3E,0x22,0x78,0x2A,0xBE,0x30,0xA2,0x57,0x4F,0xA2,0x28,
	0x0F,0x50,0x54,0xBF,0xEF,0x00,0xD1,0xC0,0xB3,0x00,0x95,0x00,0x81,0x80,0x81,0x40,
	0x81,0xC0,0x01,0x01,0x01,0x01,0x50,0xD0,0x00,0xA0,0xF0,0x70,0x3E,0x80,0x30,0x20,
	0x35,0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0xB4,0x66,0x00,0xA0,0xF0,0x70,0x1F,0x80,
	0x30,0x20,0x35,0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0x00,0x00,0x00,0xFC,0x00,0x4C,
	0x43,0x44,0x54,0x56,0x31,0x36,0x0A,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFD,
	0x00,0x17,0x50,0x1E,0x8C,0x3C,0x00,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x01,0x30,
	0x02,0x03,0x33,0xF1,0x4C,0x90,0x04,0x03,0x1F,0x13,0x01,0x12,0x5D,0x5E,0x5F,0x60,
	0x61,0x23,0x0F,0x07,0x07,0x83,0x01,0x00,0x00,0x6D,0x03,0x0C,0x00,0x10,0x00,0x39,
	0x78,0x20,0x00,0x60,0x01,0x02,0x03,0x67,0xD8,0x5D,0xC4,0x01,0x78,0x80,0x03,0xE3,
	0x0F,0x00,0x0C,0x01,0x1D,0x00,0x72,0x51,0xD0,0x1E,0x20,0x6E,0x28,0x55,0x00,0x6D,
	0x55,0x21,0x00,0x00,0x1E,0x4D,0x6C,0x80,0xA0,0x70,0x70,0x3E,0x80,0x30,0x20,0x3A,
	0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0xA3,0x66,0x00,0xA0,0xF0,0x70,0x1F,0x80,0x30,
	0x20,0x35,0x00,0x6D,0x55,0x21,0x00,0x00,0x1A,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
	0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0
};

#if 0  //mine
const uint8_t EDID_4K_60HZ_444_BYPASS[EDID_TABLE_LEN]=
{
0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x7F,0xFF,0x00,0x90,0x0F,0x00,0x00,0x00,
0x01,0x1B,0x01,0x03,0x80,0x50,0x2D,0x78,0x0A,0xEE,0x91,0xA3,0x54,0x4C,0x99,0x26,
0x0F,0x50,0x54,0x20,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x08,0xE8,0x00,0x30,0xF2,0x70,0x5A,0x80,0xB0,0x58,
0x8A,0x00,0x20,0xC2,0x31,0x00,0x00,0x1E,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,
0x58,0x2C,0x45,0x00,0x20,0xC2,0x31,0x00,0x00,0x1E,0x00,0x00,0x00,0xFD,0x00,0x18,
0x4B,0x1A,0x51,0x3C,0x00,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFC,
0x00,0x48,0x44,0x4D,0x49,0x20,0x53,0x70,0x6C,0x69,0x74,0x74,0x65,0x72,0x01,0x7C,
0x02,0x03,0x52,0x70,0x55,0x61,0x60,0x5F,0x5E,0x5D,0x66,0x65,0x64,0x63,0x62,0x10,
0x1F,0x22,0x21,0x20,0x05,0x14,0x04,0x13,0x12,0x03,0x32,0x0F,0x7F,0x07,0x15,0x07,
0x50,0x3D,0x1E,0xC0,0x57,0x07,0x01,0x5F,0x7E,0x01,0x67,0x1E,0x00,0x83,0x2F,0x00,
0x00,0x67,0x03,0x0C,0x00,0x10,0x00,0xB8,0x3C,0x67,0xD8,0x5D,0xC4,0x01,0xFF,0x80,
0x03,0xE2,0x00,0x0F,0xE3,0x05,0xFF,0x01,0xE3,0x06,0x05,0x01,0xE5,0x0E,0x61,0x60,
0x66,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD8
		
};



const uint8_t EDID_4K_60HZ_444_8CH[EDID_TABLE_LEN]=
{
0x00,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x7F,0xFF,0x00,0x90,0x0F,0x00,0x00,0x00,
0x01,0x1B,0x01,0x03,0x80,0x50,0x2D,0x78,0x0A,0xEE,0x91,0xA3,0x54,0x4C,0x99,0x26,
0x0F,0x50,0x54,0x20,0x00,0x00,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
0x01,0x01,0x01,0x01,0x01,0x01,0x08,0xE8,0x00,0x30,0xF2,0x70,0x5A,0x80,0xB0,0x58,
0x8A,0x00,0x20,0xC2,0x31,0x00,0x00,0x1E,0x02,0x3A,0x80,0x18,0x71,0x38,0x2D,0x40,
0x58,0x2C,0x45,0x00,0x20,0xC2,0x31,0x00,0x00,0x1E,0x00,0x00,0x00,0xFD,0x00,0x18,
0x4B,0x1A,0x51,0x3C,0x00,0x0A,0x20,0x20,0x20,0x20,0x20,0x20,0x00,0x00,0x00,0xFC,
0x00,0x48,0x44,0x4D,0x49,0x20,0x53,0x70,0x6C,0x69,0x74,0x74,0x65,0x72,0x01,0x7C,
0x02,0x03,0x52,0x70,0x55,0x61,0x60,0x5F,0x5E,0x5D,0x66,0x65,0x64,0x63,0x62,0x10,
0x1F,0x22,0x21,0x20,0x05,0x14,0x04,0x13,0x12,0x03,0x32,0x0F,0x7F,0x07,0x15,0x07,
0x50,0x3D,0x1E,0xC0,0x57,0x07,0x01,0x5F,0x7E,0x01,0x67,0x1E,0x00,0x83,0x2F,0x00,
0x00,0x67,0x03,0x0C,0x00,0x10,0x00,0xB8,0x3C,0x67,0xD8,0x5D,0xC4,0x01,0xFF,0x80,
0x03,0xE2,0x00,0x0F,0xE3,0x05,0xFF,0x01,0xE3,0x06,0x05,0x01,0xE5,0x0E,0x61,0x60,
0x66,0x65,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xD8

};
#endif


extern uint8_t g_Init_EdidFlashEdidTable[]; //default internal edid

unsigned char KeyValue=0xff;
unsigned char KeyKeepValue=0xff;

/*----------------------------------------------18Bytes  Data Timing Processing------------------------------------------*/
void EDIDDataProcess(BYTE *TheData)
{
	BYTE DataHighTemp = 0 , DataLow = 0, DataHigh= 0 ;
	BYTE HzTemp= 0;
	unsigned short int  DataGatherTemp = 0 ;
	BYTE DataLowTemp = 0;
	BYTE HighFour = 0;
	BYTE LowFour = 0;
	unsigned short int Data16 = 0;
	unsigned short int DataV16 = 0;
	unsigned int Data32 = 0;
	unsigned int DataM32 = 0;

	DataLowTemp  = *(TheData+2) ;   //18BYTES 的 首地址 例如 36H
	DataLow= DataLowTemp&0x0f;
	DataLowTemp  = *(TheData+2);
	DataHigh= (DataLowTemp&0xf0)>>4;     //取gao 4

	DataHighTemp = *(TheData+4);

	HighFour = (DataHighTemp&0xf0) >> 4;   //取高4位
	LowFour = (DataHighTemp&0x0f);    //取低4位
	DataGatherTemp |= HighFour;    //H - displaying
	DataGatherTemp = DataGatherTemp<<8;
	DataGatherTemp |=*(TheData+2);
	if(DataGatherTemp >= 3840)
		{
			Data16 |=LowFour ;//H-blanking
			Data16 = Data16<<8;
			Data16  |= *(TheData+3);
			Data32 |= *(TheData+1);  // Plck clock  Hz
			Data32 = Data32<<8;
			Data32 |= *TheData;
			//count    H- tatol  =  H-displaying  +  H-blanking
			Data16 = Data16 + DataGatherTemp;
			 //V - display
			DataGatherTemp  = 0;
			DataGatherTemp |=  (*(TheData +7)&0xf0);
			DataGatherTemp = DataGatherTemp<<4;
			DataGatherTemp |=*(TheData +5 );
			 // v-blanking
			DataV16 |= (*(TheData +7)&0x0f);
			DataV16 = DataV16<<8;
			DataV16 |=*(TheData +6 );
			//count    V-tatol   =  V-displaying  +  V-blanking
			DataV16 += DataGatherTemp;
			//      H-tatol  *  V-tatol
			DataM32 = DataV16*Data16;
			//FrequencyHz = Plck Clock /(H-tatol * V-tatol)
			HzTemp = Data32*10000/DataM32;  //eg: 594000000 /(4400*2250)

			 if(HzTemp >= 50)
				{
					if(HzTemp == 60)
						{
							HzTemp = 30;
							Data32= (DataM32*HzTemp)/10000;
							*TheData = Data32&0x000000ff;
							*(TheData+1) = (Data32&0x0000ff00)>>8;  //charge  bandwidth  value
						}
					else if((HzTemp >= 50)&&(HzTemp<60))
						{
							HzTemp = 25;
							Data32= (DataM32*HzTemp)/10000;
							*TheData = Data32&0x000000ff;
							*(TheData+1) = (Data32&0x0000ff00)>>8;  //charge  bandwidth  value
						}
				}
		}


}


void appSystemHDMI2_0DwonHDMI1_3(BYTE   *acEdid)
{
       unsigned short int   CountEdid;   //wyl
	BYTE   NumTemp ; //wyl
	unsigned short int  Value ; //wyl
	BYTE  ValueTemp= 0; //wyl
	BYTE  GeneralValue = 0; //wyl
	BYTE  GeneralValueHigh = 0; //wyl
	BYTE  GeneralValueLow = 0; //wyl
	unsigned short int SynthesizeValue = 0; //wyl
	BYTE  GeneralXunhuan = 0; //wyl
	BYTE  DetailTiming = 5 ; //wyl
	BYTE checksumFlag = 0; //wyl
       WORD                         i = 0;
  	// HDMI2.0降为HDMI1.3
  	for( CountEdid = 0 ; CountEdid < 256 ;  CountEdid++)
   	{
   		NumTemp=CountEdid ;
		 switch(NumTemp)
		 	{
				case Timing1:
							if(((acEdid[CountEdid]+acEdid[CountEdid+1]+acEdid[CountEdid+2])!=0)&&(acEdid[CountEdid+3]!=0xFC))
								{
								 if(((acEdid[CountEdid]+acEdid[CountEdid+1]+acEdid[CountEdid+2])!=0)&&(acEdid[CountEdid+3]!=0xFD))
								 	{
										EDIDDataProcess(&acEdid[CountEdid]);
										checksumFlag = 1;
								 	}
								}
							break;
				case Timing2:
							if(((acEdid[CountEdid]+acEdid[CountEdid+1]+acEdid[CountEdid+2])!=0)&&(acEdid[CountEdid+3]!=0xFC))
								{

								if(((acEdid[CountEdid]+acEdid[CountEdid+1]+acEdid[CountEdid+2])!=0)&&(acEdid[CountEdid+3]!=0xFD))
									{
										EDIDDataProcess(&acEdid[CountEdid]);
										checksumFlag = 1;
									}
								}
							break;
				case Timing3:
							if(((acEdid[CountEdid]+acEdid[CountEdid+1]+acEdid[CountEdid+2])!=0)&&(acEdid[CountEdid+3]!=0xFC))
								{
								if(((acEdid[CountEdid]+acEdid[CountEdid+1]+acEdid[CountEdid+2])!=0)&&(acEdid[CountEdid+3]!=0xFD))
									{
										EDIDDataProcess(&acEdid[CountEdid]);
										checksumFlag = 1;
									}
								}
							break;
				case Timing4:
							if(((acEdid[CountEdid]+acEdid[CountEdid+1]+acEdid[CountEdid+2])!=0)&&(acEdid[CountEdid+3]!=0xFC))
								{
								       if(((acEdid[CountEdid]+acEdid[CountEdid+1]+acEdid[CountEdid+2])!=0)&&(acEdid[CountEdid+3]!=0xFD))
									{
										EDIDDataProcess(&acEdid[CountEdid]);
										checksumFlag = 1;
									}
								}
							break;
				case Checksum:
							#if 0
							if(checksumFlag == 1)
								{
									    for(Value = 0; Value < 127; Value++)  //校准7fH 为0
										{
											SynthesizeValue += acEdid[Value];
										}
										ValueTemp = SynthesizeValue&0x00ff;
										SynthesizeValue = 256;
										acEdid[127] = SynthesizeValue - ValueTemp;
										Value = 0;
										SynthesizeValue =0;
										ValueTemp = 0;
										checksumFlag = 0;
								}
							#endif
							for (i = 0; i < 127; i++)  ValueTemp += acEdid[i];
                                		acEdid[127] = ~(ValueTemp - 1);
							break;

				default:            break;
		 	}

		 //对后128byte的处理

		 if(CountEdid ==NumberOffset )    //eg:82       决定18bytes Detailed Timing Descriptions的开始字节地址
		 	{
		 		Value  = acEdid[CountEdid] + 128;
			}
		 if(CountEdid==GeneralFormat )
		 	{
				GeneralValue= acEdid[CountEdid] ;
				GeneralValueHigh = (GeneralValue & 0xE0)>>5;
				GeneralValueLow =  GeneralValue & 0x1F;
				if(GeneralValueHigh == 2)
					{
						for(GeneralXunhuan = 0; GeneralXunhuan <GeneralValueLow; GeneralXunhuan ++)
							{
								if(((acEdid[CountEdid + 1]==96)&&(acEdid[CountEdid + 1]==97))||(acEdid[CountEdid + 1]==101)||(acEdid[CountEdid + 1]==102)||(acEdid[CountEdid + 1]==106)||(acEdid[CountEdid + 1]==107))
									{
										acEdid[CountEdid + 1] = acEdid[CountEdid + 1] - 2; //重新赋值 从5开始累加
										checksumFlag = 1;
									}
								CountEdid+=1;
								DetailTiming+=1;
							}
					}

		 	}
		 if(CountEdid ==Value)  //对后128byte中的分辨率进行判断
		 	{
		 		while(Value<255)
		 		{

					if(((acEdid[Value]+acEdid[Value+1]+acEdid[Value+2])!=0)&&(acEdid[Value+3]!=0xFC))
					{
					       if(((acEdid[Value]+acEdid[Value+1]+acEdid[Value+2])!=0)&&(acEdid[Value+3]!=0xFD))
						{
							EDIDDataProcess(&acEdid[Value]);
							checksumFlag = 1;
						}
					}
					Value =Value+18; //隔18bytes
		 		}

		 	}
		 if(CountEdid == 255)   //对后面128个字节进行Checksum  方式和前127byte一样
		 	{
				#if 0
				if(checksumFlag == 1)
		 	     	{
					for(GeneralXunhuan = 0; GeneralXunhuan <128; GeneralXunhuan ++)
						{
							SynthesizeValue += acEdid[GeneralXunhuan+128];
						}
						ValueTemp = SynthesizeValue&0x00ff;
						SynthesizeValue = 256;
						acEdid[255] = SynthesizeValue - ValueTemp;
		 	     	}
				#endif
				ValueTemp =0;
				for (i = 0; i < 127; i++)  ValueTemp += acEdid[i+128];
                         acEdid[255] = ~(ValueTemp - 1);
		 	}
   	}
    #if 0
    for( i = 0 ; i < 256 ;  i++)
    {
		UART1_SendByte(acEdid[i]);
    }
    #endif

}

void FirstPowerOnInternalEdidProcess(unsigned char EdidSel)
{
	  POUTPUTPORT_MANAGER_DATA     psOutputPortMgrData;
	  unsigned char i;
	  //BYTE acEDID_data[256];
	  BYTE cInput, cInSel, cOut;
	  BYTE cCNT = 0;
	  Event_t   bEvent;

	  memset(&bEvent, 0, sizeof(Event_t));
	  memset(acEDID_data, 0, 256);
	  psOutputPortMgrData = (POUTPUTPORT_MANAGER_DATA)utilDataMgrReadLockData(nnOUTPUTPORT_MANAGER_DATA);

         utilDataMgrUnlock(nnOUTPUTPORT_MANAGER_DATA,FALSE);

	  switch(EdidSel)
	  {
		case eEDID_BYPASS:
				for (cInput = 0; cInput < MAX_IN; cInput++)         //查找输入对应的输出通道
				{
				        cCNT = 0;
				        for (cOut = 0; cOut < MAX_OUT; cOut++)
				        {
				            	cInSel = psOutputPortMgrData->acInPortSelect[cOut];
				            	if (cInput == cInSel)
				            	{
						  	if(cCNT==0)
						  	{
								if ((OutputEdidData[cOut][0] == 0) && (OutputEdidData[cOut][1] == 0xff) && (OutputEdidData[cOut][3] == 0xff)&& (OutputEdidData[cOut][7] == 0))
								{
									cCNT++;
									dvNVRAMUserEdidWrite(edsEDID_IN1 + cInput, OutputEdidData[cOut]);
								}
						  	}
				            	}
				        }
				}

				sprintf(USART1_tx_buff, "EDID BYPASS 0000\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));

				KeyValue=eEDID_BYPASS;
				break;
		case eEDID_720P_2D_BYPASS:
				memcpy(acEDID_data, EDID_720P_2D_BYPASS, 256);
				EDID_BypassWithAudio(eFIRST_POWERON,(PEDIDB)acEDID_data);
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
				}

				sprintf(USART1_tx_buff, "EDID 720P 2D BYPASS 0001\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));

				KeyValue=eEDID_720P_2D_BYPASS;
				break;
		case eEDID_720P_3D_BYPASS:
			       memcpy(acEDID_data, EDID_720P_3D_BYPASS, 256);
				EDID_BypassWithAudio(eFIRST_POWERON,(PEDIDB)acEDID_data);
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
				}

				sprintf(USART1_tx_buff, "EDID 720P 3D BYPASS 0010\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));

				KeyValue=eEDID_720P_3D_BYPASS;
				break;
		case eEDID_1080P_2D_BYPASS:
			  	memcpy(acEDID_data, EDID_1080P_2D_BYPASS, 256);
				EDID_BypassWithAudio(eFIRST_POWERON,(PEDIDB)acEDID_data);
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
				}
				sprintf(USART1_tx_buff, "EDID 1080P 2D BYPASS 0011\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				KeyValue=eEDID_1080P_2D_BYPASS;
				break;
		case eEDID_1080P_3D_BYPASS:
				memcpy(acEDID_data, EDID_1080P_3D_BYPASS, 256);
				EDID_BypassWithAudio(eFIRST_POWERON,(PEDIDB)acEDID_data);
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
				}
				sprintf(USART1_tx_buff, "EDID 1080P 3D BYPASS 0100\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				KeyValue=eEDID_1080P_3D_BYPASS;
				break;
		case eEDID_4K_30HZ_BYPASS:
				memcpy(acEDID_data, EDID_4K_30HZ_BYPASS, 256);
				EDID_BypassWithAudio(eFIRST_POWERON,(PEDIDB)acEDID_data);
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
				}
				sprintf(USART1_tx_buff, "EDID 4K 30HZ BYPASS 0101\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				KeyValue=eEDID_4K_30HZ_BYPASS;
				break;
		case eEDID_4K_30HZ_2CH:
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, (PBYTE)EDID_4K_30HZ_2CH);
				}
				sprintf(USART1_tx_buff, "EDID 4K 30HZ 2.0CH 0110\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				KeyValue=eEDID_4K_30HZ_2CH;
				break;
		case eEDID_4K_30HZ_8CH:
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, (PBYTE)EDID_4K_30HZ_8CH);
				}
				sprintf(USART1_tx_buff, "EDID 4K 30HZ 7.1CH 0111\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				KeyValue=eEDID_4K_30HZ_8CH;
				break;
		case eEDID_4K_60HZ_420_BYPASS:
				memcpy(acEDID_data, EDID_4K_60HZ_420_BYPASS, 256);
				EDID_BypassWithAudio(eFIRST_POWERON,(PEDIDB)acEDID_data);
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
				}
				sprintf(USART1_tx_buff, "EDID 4K 60HZ 420 BYPASS 1000\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				KeyValue=eEDID_4K_60HZ_420_BYPASS;
				break;
		case eEDID_4K_60HZ_420_8CH:
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, (PBYTE)EDID_4K_60HZ_420_8CH);
				}
				sprintf(USART1_tx_buff, "EDID 4K 60HZ 420 7.1CH 1001\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				KeyValue=eEDID_4K_60HZ_420_8CH;
				break;
		case eEDID_4K_60HZ_444_BYPASS:
				memcpy(acEDID_data, EDID_4K_60HZ_444_BYPASS, 256);
				EDID_BypassWithAudio(eFIRST_POWERON,(PEDIDB)acEDID_data);
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
				}
				sprintf(USART1_tx_buff, "EDID 4K 60HZ 444 BYPASS 1010\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				KeyValue=eEDID_4K_60HZ_444_BYPASS;
				break;
		case eEDID_4K_60HZ_444_8CH:
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, (PBYTE)EDID_4K_60HZ_444_8CH);
				}
				sprintf(USART1_tx_buff, "EDID 4K 60HZ 444 7.1CH 1011\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				KeyValue=eEDID_4K_60HZ_444_8CH;
				break;
		case eEDID_RS232_GUI_CONTROL:
				sprintf(USART1_tx_buff, "EDID RS232 GUI CONTROL 1111\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				KeyValue=eEDID_RS232_GUI_CONTROL;
				break;
		default:break;
	  }
}

void InternalEdidProcess(unsigned char EdidSel, unsigned char en)
{
	  unsigned char i;
	  //BYTE acEDID_data[256];
	  BYTE cInput, cInSel, cOut;
	  BYTE cCNT = 0,crc=0;
	  Event_t   bEvent;
	  WORD conut=0;
	  POUTPUTPORT_MANAGER_DATA     psOutputPortMgrData;

	  memset(&bEvent, 0, sizeof(Event_t));
	  memset(acEDID_data, 0, 256);
	  psOutputPortMgrData = (POUTPUTPORT_MANAGER_DATA)utilDataMgrReadLockData(nnOUTPUTPORT_MANAGER_DATA);

         utilDataMgrUnlock(nnOUTPUTPORT_MANAGER_DATA,FALSE);

	  switch(EdidSel)
	  {
		case eEDID_BYPASS:
				for (cInput = 0; cInput < MAX_IN; cInput++)         //查找输入对应的输出通道
				{
				        cCNT = 0;
				        for (cOut = 0; cOut < MAX_OUT; cOut++)
				        {
				            	cInSel = psOutputPortMgrData->acInPortSelect[cOut];
				            	if (cInput == cInSel)
				            	{
							if(cCNT==0)
						  	{
								#if 1
								if ((OutputEdidData[cOut][0] == 0) && (OutputEdidData[cOut][1] == 0xff) && (OutputEdidData[cOut][3] == 0xff)&& (OutputEdidData[cOut][7] == 0))
								{
									if(OutputEdidData[cOut][126] != 1)			// DVI
								       {
										for (conut = 0; conut < 128; conut++)  crc += OutputEdidData[cOut][conut] ;
										for (conut = 128; conut < 256; conut++)    OutputEdidData[cOut][conut] = 0xff;
								       }
								       else
								       {
										for (conut = 0; conut < 256; conut++)  crc += OutputEdidData[cOut][conut] ;
								       }
								       if(crc !=0)
									 	memcpy(OutputEdidData[cOut],g_Init_EdidFlashEdidTable,  256); //否则就用默认的EDID数据

								       cCNT++;
								       dvNVRAMUserEdidWrite(edsEDID_IN1 + cInput, OutputEdidData[cOut]);
								       sii_set_rx_edid_content(cInput,0, OutputEdidData[cOut]);
								       sii_set_rx_edid_content(cInput,1, &OutputEdidData[cOut][128]);
								}
								#endif
								#if 0
								if (TRUE==SiiTxHpdGet(utilOutputPortToInstance(cOut)))
							       {
									SiiTxEdidGetEdidData(utilOutputPortToInstance(cOut), acEDID_data);
									if ((acEDID_data[0] == 0) && (acEDID_data[1] == 0xff) && (acEDID_data[3] == 0xff)&& (acEDID_data[7] == 0))
								       {
									     if(acEDID_data[126] != 1)			// DVI
									     {
											for (conut = 0; conut < 128; conut++)  crc += acEDID_data[conut] ;
											for (conut = 128; conut < 256; conut++)    acEDID_data[conut] = 0xff;
									     }
									     else
									     {
											for (conut = 0; conut < 256; conut++)  crc += acEDID_data[conut] ;
									     }
									     if(crc !=0)
										 	memcpy(acEDID_data,g_Init_EdidFlashEdidTable,  256); //否则就用默认的EDID数据

									     cCNT++;
									     dvNVRAMUserEdidWrite(edsEDID_IN1 + cInput, acEDID_data);
									     sii_set_rx_edid_content(cInput,0, acEDID_data);
									     sii_set_rx_edid_content(cInput,1, &acEDID_data[128]);
								       }
									memset(acEDID_data, 0, 256);
							       }
								#endif
						  	}
				            	}
				        }
				}

				bEvent.Head.opcode=eInputHpdProc; 			//发送进行所有输入端口热拔插拉低再拉高的消息
			    	bEvent.Head.DestAddr=mqINPUT;
				bEvent.args[MAX_IN]=1;					//记录要进行热插拔脚拉低再拉高的输入端口
			    	bEvent.Head.argCount=MAX_IN+1;
			    	utilExecOlnyMsgSend(mqINPUT, bEvent);
				SiiPlatformTimerSet(etEDIDPROC_HPD,mS_TO_TICKS(2000) ,1);   // 只执行一次

				sprintf(USART1_tx_buff, "EDID BYPASS 0000\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				if(en==1)
					KeyValue=eEDID_BYPASS;
				break;
		case eEDID_720P_2D_BYPASS:
				memcpy(acEDID_data, EDID_720P_2D_BYPASS, 256);
				EDID_BypassWithAudio(eALREADY_POWERON,(PEDIDB)acEDID_data);
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
				}
				SiiSetRxEdidSramWrite(0, acEDID_data, 256,ALL_INPORT);

				sprintf(USART1_tx_buff, "EDID 720P 2D BYPASS 0001\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				if(en==1)
					KeyValue=eEDID_720P_2D_BYPASS;
				break;
		case eEDID_720P_3D_BYPASS:
			       memcpy(acEDID_data, EDID_720P_3D_BYPASS, 256);
				EDID_BypassWithAudio(eALREADY_POWERON,(PEDIDB)acEDID_data);
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
				}
				SiiSetRxEdidSramWrite(0, acEDID_data, 256,ALL_INPORT);

				sprintf(USART1_tx_buff, "EDID 720P 3D BYPASS 0010\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));

				if(en==1)
					KeyValue=eEDID_720P_3D_BYPASS;
				break;
		case eEDID_1080P_2D_BYPASS:
			  	memcpy(acEDID_data, EDID_1080P_2D_BYPASS, 256);
				EDID_BypassWithAudio(eALREADY_POWERON,(PEDIDB)acEDID_data);
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
				}
				SiiSetRxEdidSramWrite(0, acEDID_data, 256,ALL_INPORT);
				sprintf(USART1_tx_buff, "EDID 1080P 2D BYPASS 0011\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				if(en==1)
					KeyValue=eEDID_1080P_2D_BYPASS;
				break;
		case eEDID_1080P_3D_BYPASS:
				memcpy(acEDID_data, EDID_1080P_3D_BYPASS, 256);
				EDID_BypassWithAudio(eALREADY_POWERON,(PEDIDB)acEDID_data);
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
				}
				SiiSetRxEdidSramWrite(0, acEDID_data, 256,ALL_INPORT);
				sprintf(USART1_tx_buff, "EDID 1080P 3D BYPASS 0100\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				if(en==1)
					KeyValue=eEDID_1080P_3D_BYPASS;
				break;
		case eEDID_4K_30HZ_BYPASS:
				memcpy(acEDID_data, EDID_4K_30HZ_BYPASS, 256);
				EDID_BypassWithAudio(eALREADY_POWERON,(PEDIDB)acEDID_data);
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
				}
				SiiSetRxEdidSramWrite(0, acEDID_data, 256,ALL_INPORT);
				sprintf(USART1_tx_buff, "EDID 4K 30HZ BYPASS 0101\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				if(en==1)
					KeyValue=eEDID_4K_30HZ_BYPASS;
				break;
		case eEDID_4K_30HZ_2CH:
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, (PBYTE)EDID_4K_30HZ_2CH);
				}
				SiiSetRxEdidSramWrite(0, (PBYTE)EDID_4K_30HZ_2CH, 256,ALL_INPORT);
				sprintf(USART1_tx_buff, "EDID 4K 30HZ 2.0CH 0110\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				if(en==1)
					KeyValue=eEDID_4K_30HZ_2CH;
				break;
		case eEDID_4K_30HZ_8CH:
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, (PBYTE)EDID_4K_30HZ_8CH);
				}
				SiiSetRxEdidSramWrite(0, (PBYTE)EDID_4K_30HZ_8CH, 256,ALL_INPORT);
				sprintf(USART1_tx_buff, "EDID 4K 30HZ 7.1CH 0111\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				if(en==1)
					KeyValue=eEDID_4K_30HZ_8CH;
				break;
		case eEDID_4K_60HZ_420_BYPASS:
				memcpy(acEDID_data, EDID_4K_60HZ_420_BYPASS, 256);
				EDID_BypassWithAudio(eALREADY_POWERON,(PEDIDB)acEDID_data);
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
				}
				SiiSetRxEdidSramWrite(0, acEDID_data, 256,ALL_INPORT);
				sprintf(USART1_tx_buff, "EDID 4K 60HZ 420 BYPASS 1000\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				if(en==1)
					KeyValue=eEDID_4K_60HZ_420_BYPASS;
				break;
		case eEDID_4K_60HZ_420_8CH:
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, (PBYTE)EDID_4K_60HZ_420_8CH);
				}
				SiiSetRxEdidSramWrite(0,(PBYTE)EDID_4K_60HZ_420_8CH, 256,ALL_INPORT);
				sprintf(USART1_tx_buff, "EDID 4K 60HZ 420 7.1CH 1001\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				if(en==1)
					KeyValue=eEDID_4K_60HZ_420_8CH;
				break;
		case eEDID_4K_60HZ_444_BYPASS:
				memcpy(acEDID_data, EDID_4K_60HZ_444_BYPASS, 256);
				EDID_BypassWithAudio(eALREADY_POWERON,(PEDIDB)acEDID_data);
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
				}
				SiiSetRxEdidSramWrite(0, acEDID_data, 256,ALL_INPORT);
				sprintf(USART1_tx_buff, "EDID 4K 60HZ 444 BYPASS 1010\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				if(en==1)
					KeyValue=eEDID_4K_60HZ_444_BYPASS;
				break;
		case eEDID_4K_60HZ_444_8CH:
				for(i=0;i<MAX_IN;i++)
				{
					dvNVRAMUserEdidWrite(edsEDID_IN1 + i, (PBYTE)EDID_4K_60HZ_444_8CH);
				}
				SiiSetRxEdidSramWrite(0, (PBYTE)EDID_4K_60HZ_444_8CH, 256,ALL_INPORT);
				sprintf(USART1_tx_buff, "EDID 4K 60HZ 444 7.1CH 1011\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				if(en==1)
					KeyValue=eEDID_4K_60HZ_444_8CH;
				break;
		case eEDID_RS232_GUI_CONTROL:
				sprintf(USART1_tx_buff, "EDID RS232 GUI CONTROL 1111\r\n");
					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
				if(en==1)
					KeyValue=eEDID_RS232_GUI_CONTROL;
				break;
		default:break;
	  }
}

void GuiUartInternalEdidProcess(unsigned char inport, unsigned char EdidSel)
{
	  POUTPUTPORT_MANAGER_DATA     psOutputPortMgrData;
	  //BYTE acEDID_data[256];
	  BYTE cInSel, cOut;
	  BYTE cCNT = 0,crc=0;
	  Event_t   bEvent;
	  WORD conut=0;

	  memset(&bEvent, 0, sizeof(Event_t));
	  memset(acEDID_data, 0, 256);
	  psOutputPortMgrData = (POUTPUTPORT_MANAGER_DATA)utilDataMgrReadLockData(nnOUTPUTPORT_MANAGER_DATA);

         utilDataMgrUnlock(nnOUTPUTPORT_MANAGER_DATA,FALSE);

	  switch(EdidSel)
	  {
		case eEDID_BYPASS:
			       cCNT = 0;
			       for (cOut = 0; cOut < MAX_OUT; cOut++)			//查找输入对应的输出通道
			       {
			            	cInSel = psOutputPortMgrData->acInPortSelect[cOut];
			            	if (inport == cInSel)
			            	{
						if(cCNT==0)
					  	{
							#if 1
							if ((OutputEdidData[cOut][0] == 0) && (OutputEdidData[cOut][1] == 0xff) && (OutputEdidData[cOut][3] == 0xff)&& (OutputEdidData[cOut][7] == 0))
							{
								if(OutputEdidData[cOut][126] != 1)			// DVI
							       {
									for (conut = 0; conut < 128; conut++)  crc += OutputEdidData[cOut][conut] ;
									for (conut = 128; conut < 256; conut++)    OutputEdidData[cOut][conut] = 0xff;
							       }
							       else
							       {
									for (conut = 0; conut < 256; conut++)  crc += OutputEdidData[cOut][conut] ;
							       }
							       if(crc !=0)
								 	memcpy(OutputEdidData[cOut],g_Init_EdidFlashEdidTable,  256); //否则就用默认的EDID数据

							       cCNT++;
							       dvNVRAMUserEdidWrite(edsEDID_IN1 + inport, OutputEdidData[cOut]);
							       sii_set_rx_edid_content(inport,0, OutputEdidData[cOut]);
							       sii_set_rx_edid_content(inport,1, &OutputEdidData[cOut][128]);
							}
							#endif

							#if 0
							if (TRUE==SiiTxHpdGet(utilOutputPortToInstance(cOut)))
						       {
								SiiTxEdidGetEdidData(utilOutputPortToInstance(cOut), acEDID_data);
								if ((acEDID_data[0] == 0) && (acEDID_data[1] == 0xff) && (acEDID_data[3] == 0xff)&& (acEDID_data[7] == 0))
							       {
								     if(acEDID_data[126] != 1)			// DVI
								     {
										for (conut = 0; conut < 128; conut++)  crc += acEDID_data[conut] ;
										for (conut = 128; conut < 256; conut++)    acEDID_data[conut] = 0xff;
								     }
								     else
								     {
										for (conut = 0; conut < 256; conut++)  crc += acEDID_data[conut] ;
								     }
								     if(crc !=0)
									 	memcpy(acEDID_data,g_Init_EdidFlashEdidTable,  256); //否则就用默认的EDID数据

								     cCNT++;
								     dvNVRAMUserEdidWrite(edsEDID_IN1 + inport, acEDID_data);
								     sii_set_rx_edid_content(inport,0, acEDID_data);
								     sii_set_rx_edid_content(inport,1, &acEDID_data[128]);
							       }
								memset(acEDID_data, 0, 256);
						       }
							#endif
					  	}
			            	}
			       }

				KeyValue=eEDID_RS232_GUI_CONTROL;
				break;
		case eEDID_720P_2D_BYPASS:
				memcpy(acEDID_data, EDID_720P_2D_BYPASS, 256);
				EDID_BypassWithAudio(eALREADY_POWERON,(PEDIDB)acEDID_data);
				dvNVRAMUserEdidWrite(edsEDID_IN1 + inport, acEDID_data);
				sii_set_rx_edid_content(inport,0, acEDID_data);
				sii_set_rx_edid_content(inport,1, &acEDID_data[128]);

				KeyValue=eEDID_RS232_GUI_CONTROL;
				break;
		case eEDID_720P_3D_BYPASS:
			       memcpy(acEDID_data, EDID_720P_3D_BYPASS, 256);
				EDID_BypassWithAudio(eALREADY_POWERON,(PEDIDB)acEDID_data);
				dvNVRAMUserEdidWrite(edsEDID_IN1 + inport, acEDID_data);
				sii_set_rx_edid_content(inport,0, acEDID_data);
				sii_set_rx_edid_content(inport,1, &acEDID_data[128]);

				KeyValue=eEDID_RS232_GUI_CONTROL;
				break;
		case eEDID_1080P_2D_BYPASS:
			  	memcpy(acEDID_data, EDID_1080P_2D_BYPASS, 256);
				EDID_BypassWithAudio(eALREADY_POWERON,(PEDIDB)acEDID_data);
				dvNVRAMUserEdidWrite(edsEDID_IN1 + inport, acEDID_data);
				sii_set_rx_edid_content(inport,0, acEDID_data);
				sii_set_rx_edid_content(inport,1, &acEDID_data[128]);

				KeyValue=eEDID_RS232_GUI_CONTROL;
				break;
		case eEDID_1080P_3D_BYPASS:
				memcpy(acEDID_data, EDID_1080P_3D_BYPASS, 256);
				EDID_BypassWithAudio(eALREADY_POWERON,(PEDIDB)acEDID_data);
				dvNVRAMUserEdidWrite(edsEDID_IN1 + inport, acEDID_data);
				sii_set_rx_edid_content(inport,0, acEDID_data);
				sii_set_rx_edid_content(inport,1, &acEDID_data[128]);

				KeyValue=eEDID_RS232_GUI_CONTROL;
				break;
		case eEDID_4K_30HZ_BYPASS:
				memcpy(acEDID_data, EDID_4K_30HZ_BYPASS, 256);
				EDID_BypassWithAudio(eALREADY_POWERON,(PEDIDB)acEDID_data);
				dvNVRAMUserEdidWrite(edsEDID_IN1 + inport, acEDID_data);
				sii_set_rx_edid_content(inport,0, acEDID_data);
				sii_set_rx_edid_content(inport,1, &acEDID_data[128]);

				KeyValue=eEDID_RS232_GUI_CONTROL;
				break;
		case eEDID_4K_30HZ_2CH:
				dvNVRAMUserEdidWrite(edsEDID_IN1 + inport, (PBYTE)EDID_4K_30HZ_2CH);
				sii_set_rx_edid_content(inport,0, (PBYTE)EDID_4K_30HZ_2CH);
				sii_set_rx_edid_content(inport,1, (PBYTE)&EDID_4K_30HZ_2CH[128]);

				KeyValue=eEDID_RS232_GUI_CONTROL;
				break;
		case eEDID_4K_30HZ_8CH:
				dvNVRAMUserEdidWrite(edsEDID_IN1 + inport, (PBYTE)EDID_4K_30HZ_8CH);
				sii_set_rx_edid_content(inport,0, (PBYTE)EDID_4K_30HZ_8CH);
				sii_set_rx_edid_content(inport,1, (PBYTE)&EDID_4K_30HZ_8CH[128]);

				KeyValue=eEDID_RS232_GUI_CONTROL;
				break;
		case eEDID_4K_60HZ_420_BYPASS:
				memcpy(acEDID_data, EDID_4K_60HZ_420_BYPASS, 256);
				EDID_BypassWithAudio(eALREADY_POWERON,(PEDIDB)acEDID_data);
				dvNVRAMUserEdidWrite(edsEDID_IN1 + inport, acEDID_data);
				sii_set_rx_edid_content(inport,0, acEDID_data);
				sii_set_rx_edid_content(inport,1, &acEDID_data[128]);

				KeyValue=eEDID_RS232_GUI_CONTROL;
				break;
		case eEDID_4K_60HZ_420_8CH:
				dvNVRAMUserEdidWrite(edsEDID_IN1 + inport, (PBYTE)EDID_4K_60HZ_420_8CH);
				sii_set_rx_edid_content(inport,0, (PBYTE)EDID_4K_60HZ_420_8CH);
				sii_set_rx_edid_content(inport,1, (PBYTE)&EDID_4K_60HZ_420_8CH[128]);

				KeyValue=eEDID_RS232_GUI_CONTROL;
				break;
		case eEDID_4K_60HZ_444_BYPASS:
				memcpy(acEDID_data, EDID_4K_60HZ_444_BYPASS, 256);
				EDID_BypassWithAudio(eALREADY_POWERON,(PEDIDB)acEDID_data);
				dvNVRAMUserEdidWrite(edsEDID_IN1 + inport, acEDID_data);
				sii_set_rx_edid_content(inport,0, acEDID_data);
				sii_set_rx_edid_content(inport,1, &acEDID_data[128]);

				KeyValue=eEDID_RS232_GUI_CONTROL;
				break;
		case eEDID_4K_60HZ_444_8CH:
				dvNVRAMUserEdidWrite(edsEDID_IN1 + inport, (PBYTE)EDID_4K_60HZ_444_8CH);
				sii_set_rx_edid_content(inport,0, (PBYTE)EDID_4K_60HZ_444_8CH);
				sii_set_rx_edid_content(inport,1, (PBYTE)&EDID_4K_60HZ_444_8CH[128]);

				KeyValue=eEDID_RS232_GUI_CONTROL;
				break;
		default:break;
	  }

	  //sprintf(USART1_tx_buff, "EDID/%d/%d", inport+1, EdidSel);
	  //UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
}

unsigned char EDID_DialSwitchKey_Scan(void)		//拨码快关拨码扫描
{
	unsigned int KeyTem1,KeyTem2;
	unsigned char EDIDKey;
	KeyTem1=GPIOC->IDR & 0x1E00 ;
	delay_nms(2);
	KeyTem2=GPIOC->IDR & 0x1E00 ;
	if((KeyTem1&0x1E00)==(KeyTem2&0x1E00))
	{
		EDIDKey=(KeyTem2&0x1E00)>>9;
		EDIDKey=~EDIDKey;				//取反
		EDIDKey&=0x0f;					//保留低4位
	}
	else
		EDIDKey=0xFF;
	return EDIDKey;
}

// 输入端的EDID拨码选择检测
void appInputPortDialSwitchEdidDataDetect(void)			//******处理EDID******************/
{
       unsigned char KeyValueTem,i=0,cCNT=0;
	unsigned char InEdidValue[MAX_IN]={0};
	Event_t   bEvent;

	memset(&bEvent, 0, sizeof(Event_t));

       KeyValueTem= EDID_DialSwitchKey_Scan();
   	if(KeyKeepValue!= KeyValueTem&&KeyValueTem!=0xFF)
   	{
                KeyKeepValue= KeyValueTem;
		  if(KeyValue!=0xff)					// 不是第一次上电才要定时处理拨码开关的值
		  	SiiPlatformTimerSet(etINPORTMAG_EDID,mS_TO_TICKS(3000) ,1);
   	}

	if(KeyValue!=0xff)
	{
		if(!SiiPlatformTimerExpired(etINPORTMAG_EDID))
	       {
	  	   return; 		// time not enougth
	       }
	}

	if(KeyValue==0xff)									//第一次上电进来这里
	{
		  FirstPowerOnInternalEdidProcess(KeyKeepValue);
	}
	else  if((KeyValue==eEDID_RS232_GUI_CONTROL)&&(KeyValueTem==eEDID_RS232_GUI_CONTROL))		//串口或gui的edid处理
	{
		  GetUartInEdidValue(InEdidValue);
		  for(i=0;i<MAX_IN;i++)
		  {
			if(InEdidValue[i]!=0xff)
			{
                cCNT=1;
				GuiUartInternalEdidProcess(i, InEdidValue[i]);
			}
		  }
          if(cCNT==1)
          {
    		  bEvent.Head.opcode=eInputHpdProc; 			//发送进行所有输入端口热拔插拉低再拉高的消息
        	  bEvent.Head.DestAddr=mqINPUT;
    	      bEvent.args[MAX_IN]=MAX_IN;						//记录要进行热插拔脚拉低再拉高的输入端口
        	  bEvent.Head.argCount=MAX_IN+2;
        	  utilExecOlnyMsgSend(mqINPUT, bEvent);
    	      SiiPlatformTimerSet(etEDIDPROC_HPD,mS_TO_TICKS(2000) ,1);   // 只执行一次
    	  }
	}
	else
	{
		  InternalEdidProcess(KeyKeepValue, 1);			//edid拨码开关的处理
	}
}


#if 0
void appInputPortDialSwitchEdidDataTest(void)
{
	POUTPUTPORT_MANAGER_DATA     psOutputPortMgrData;
	unsigned char i,j;
       unsigned char KeyValueTem;
	BYTE acEDID_data[256];
	BYTE cInput, cInSel, cOut;
	BYTE cCNT = 0;
	Event_t   bEvent;

       memset(&bEvent, 0, sizeof(Event_t));
	psOutputPortMgrData = (POUTPUTPORT_MANAGER_DATA)utilDataMgrReadLockData(nnOUTPUTPORT_MANAGER_DATA);

       utilDataMgrUnlock(nnOUTPUTPORT_MANAGER_DATA,FALSE);

       KeyValueTem= EDID_DialSwitchKey_Scan();
   	if(KeyKeepValue!= KeyValueTem&&KeyValueTem!=0xFF)
   	{
                KeyKeepValue= KeyValueTem;
	         KeyValue = KeyKeepValue;
   	}


	if(KeyValue==0xff)				//第一次上电进来这里
	{
		  switch(KeyKeepValue)
		  {
			case eEDID_BYPASS:
					KeyValue=eEDID_BYPASS;
					break;
			case eEDID_720P_2D_BYPASS:
					KeyValue=eEDID_720P_2D_BYPASS;
					break;
			case eEDID_720P_3D_BYPASS:
					KeyValue=eEDID_720P_3D_BYPASS;
					break;
			case eEDID_1080P_2D_BYPASS:
					KeyValue=eEDID_1080P_2D_BYPASS;
					break;
			case eEDID_1080P_3D_BYPASS:
					KeyValue=eEDID_1080P_3D_BYPASS;
					break;
			case eEDID_4K_30HZ_BYPASS:
					KeyValue=eEDID_4K_30HZ_BYPASS;
					break;
			case eEDID_4K_30HZ_2CH:
					KeyValue=eEDID_4K_30HZ_2CH;
					break;
			case eEDID_4K_30HZ_8CH:
					KeyValue=eEDID_4K_30HZ_8CH;
					break;
			case eEDID_4K_60HZ_420_BYPASS:
					KeyValue=eEDID_4K_60HZ_420_BYPASS;
					break;
			case eEDID_4K_60HZ_420_8CH:
					KeyValue=eEDID_4K_60HZ_420_8CH;
					break;
			case eEDID_4K_60HZ_444_BYPASS:
					KeyValue=eEDID_4K_60HZ_444_BYPASS;
					break;
			case eEDID_4K_60HZ_444_8CH:
					KeyValue=eEDID_4K_60HZ_444_8CH;
					break;
			case eEDID_RS232_GUI_CONTROL:
					KeyValue=eEDID_RS232_GUI_CONTROL;
					break;
			default:break;
		  }
	}
	else
	{
            	  switch(KeyKeepValue)
		  {
			case eEDID_BYPASS:
					for (cInput = 0; cInput < MAX_IN; cInput++)         //查找输入对应的输出通道
					{
					        cCNT = 0;
					        for (cOut = 0; cOut < MAX_OUT; cOut++)
					        {
					            	cInSel = psOutputPortMgrData->acInPortSelect[cOut];
					            	if (cInput == cInSel)
					            	{
							  	if(cCNT==0)
							  	{
									if (TRUE==SiiTxHpdGet(utilOutputPortToInstance(cOut)))
								       {
										SiiTxEdidGetEdidData(utilOutputPortToInstance(cOut), acEDID_data);
										if ((acEDID_data[0] == 0) && (acEDID_data[1] == 0xff) && (acEDID_data[3] == 0xff)&& (acEDID_data[7] == 0))
									       {
									            cCNT++;
										     dvNVRAMUserEdidWrite(edsEDID_IN1 + cInput, acEDID_data);
										     sii_set_rx_edid_content(cInput,0, acEDID_data);
										     sii_set_rx_edid_content(cInput,1, &acEDID_data[128]);
									       }
										memset(acEDID_data, 0, 256);
								       }
							  	}
					            	}
					        }
					}

					bEvent.Head.opcode=eInputHpdProc; 			//发送进行所有输入端口热拔插拉低再拉高的消息
				    	bEvent.Head.DestAddr=mqINPUT;
					bEvent.args[MAX_IN]=1;					//记录要进行热插拔脚拉低再拉高的输入端口
				    	bEvent.Head.argCount=MAX_IN+1;
				    	utilExecOlnyMsgSend(mqINPUT, bEvent);
					SiiPlatformTimerSet(etEDIDPROC_HPD,mS_TO_TICKS(2000) ,1);   // 只执行一次

					sprintf(USART1_tx_buff, "EDID BYPASS 0000\r\n");
    					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));

					KeyValue=eEDID_BYPASS;
					break;
			case eEDID_720P_2D_BYPASS:
					memcpy(acEDID_data, EDID_720P_2D_BYPASS, 256);
					EDID_BypassWithAudio((PEDIDB)acEDID_data);
					for(i=0;i<MAX_IN;i++)
					{
						dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
					}
					SiiSetRxEdidSramWrite(0, acEDID_data, 256,ALL_INPORT);

					sprintf(USART1_tx_buff, "EDID 720P 2D BYPASS 0001\r\n");
    					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));

					KeyValue=eEDID_720P_2D_BYPASS;
					break;
			case eEDID_720P_3D_BYPASS:
				       memcpy(acEDID_data, EDID_720P_3D_BYPASS, 256);
					EDID_BypassWithAudio((PEDIDB)acEDID_data);
					for(i=0;i<MAX_IN;i++)
					{
						dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
					}
					SiiSetRxEdidSramWrite(0, acEDID_data, 256,ALL_INPORT);

					sprintf(USART1_tx_buff, "EDID 720P 3D BYPASS 0010\r\n");
    					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));

					KeyValue=eEDID_720P_3D_BYPASS;
					break;
			case eEDID_1080P_2D_BYPASS:
				  	memcpy(acEDID_data, EDID_1080P_2D_BYPASS, 256);
					EDID_BypassWithAudio((PEDIDB)acEDID_data);
					for(i=0;i<MAX_IN;i++)
					{
						dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
					}
					SiiSetRxEdidSramWrite(0, acEDID_data, 256,ALL_INPORT);
					sprintf(USART1_tx_buff, "EDID 1080P 2D BYPASS 0011\r\n");
    					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
					KeyValue=eEDID_1080P_2D_BYPASS;
					break;
			case eEDID_1080P_3D_BYPASS:
					memcpy(acEDID_data, EDID_1080P_3D_BYPASS, 256);
					EDID_BypassWithAudio((PEDIDB)acEDID_data);
					for(i=0;i<MAX_IN;i++)
					{
						dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
					}
					SiiSetRxEdidSramWrite(0, acEDID_data, 256,ALL_INPORT);
					sprintf(USART1_tx_buff, "EDID 1080P 3D BYPASS 0100\r\n");
    					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
					KeyValue=eEDID_1080P_3D_BYPASS;
					break;
			case eEDID_4K_30HZ_BYPASS:
					memcpy(acEDID_data, EDID_4K_30HZ_BYPASS, 256);
					EDID_BypassWithAudio((PEDIDB)acEDID_data);
					for(i=0;i<MAX_IN;i++)
					{
						dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
					}
					SiiSetRxEdidSramWrite(0, acEDID_data, 256,ALL_INPORT);
					sprintf(USART1_tx_buff, "EDID 4K 30HZ BYPASS 0101\r\n");
    					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
					KeyValue=eEDID_4K_30HZ_BYPASS;
					break;
			case eEDID_4K_30HZ_2CH:
					for(i=0;i<MAX_IN;i++)
					{
						dvNVRAMUserEdidWrite(edsEDID_IN1 + i, EDID_4K_30HZ_2CH);
					}
					SiiSetRxEdidSramWrite(0, EDID_4K_30HZ_2CH, 256,ALL_INPORT);
					sprintf(USART1_tx_buff, "EDID 4K 30HZ 2.0CH 0110\r\n");
    					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
					KeyValue=eEDID_4K_30HZ_2CH;
					break;
			case eEDID_4K_30HZ_8CH:
					for(i=0;i<MAX_IN;i++)
					{
						dvNVRAMUserEdidWrite(edsEDID_IN1 + i, EDID_4K_30HZ_8CH);
					}
					SiiSetRxEdidSramWrite(0, EDID_4K_30HZ_8CH, 256,ALL_INPORT);
					sprintf(USART1_tx_buff, "EDID 4K 30HZ 7.1CH 0111\r\n");
    					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
					KeyValue=eEDID_4K_30HZ_8CH;
					break;
			case eEDID_4K_60HZ_420_BYPASS:
					memcpy(acEDID_data, EDID_4K_60HZ_420_BYPASS, 256);
					EDID_BypassWithAudio((PEDIDB)acEDID_data);
					for(i=0;i<MAX_IN;i++)
					{
						dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
					}
					SiiSetRxEdidSramWrite(0, acEDID_data, 256,ALL_INPORT);
					sprintf(USART1_tx_buff, "EDID 4K 60HZ 420 BYPASS 1000\r\n");
    					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
					KeyValue=eEDID_4K_60HZ_420_BYPASS;
					break;
			case eEDID_4K_60HZ_420_8CH:
					for(i=0;i<MAX_IN;i++)
					{
						dvNVRAMUserEdidWrite(edsEDID_IN1 + i, EDID_4K_60HZ_420_8CH);
					}
					SiiSetRxEdidSramWrite(0, EDID_4K_60HZ_420_8CH, 256,ALL_INPORT);
					sprintf(USART1_tx_buff, "EDID 4K 60HZ 420 7.1CH 1001\r\n");
    					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
					KeyValue=eEDID_4K_60HZ_420_8CH;
					break;
			case eEDID_4K_60HZ_444_BYPASS:
					memcpy(acEDID_data, EDID_4K_60HZ_444_BYPASS, 256);
					EDID_BypassWithAudio((PEDIDB)acEDID_data);
					for(i=0;i<MAX_IN;i++)
					{
						dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEDID_data);
					}
					SiiSetRxEdidSramWrite(0, acEDID_data, 256,ALL_INPORT);
					sprintf(USART1_tx_buff, "EDID 4K 60HZ 444 BYPASS 1010\r\n");
    					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
					KeyValue=eEDID_4K_60HZ_444_BYPASS;
					break;
			case eEDID_4K_60HZ_444_8CH:
					for(i=0;i<MAX_IN;i++)
					{
						dvNVRAMUserEdidWrite(edsEDID_IN1 + i, EDID_4K_60HZ_444_8CH);
					}
					SiiSetRxEdidSramWrite(0, EDID_4K_60HZ_444_8CH, 256,ALL_INPORT);
					sprintf(USART1_tx_buff, "EDID 4K 60HZ 444 7.1CH 1011\r\n");
    					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
					KeyValue=eEDID_4K_60HZ_444_8CH;
					break;
			case eEDID_RS232_GUI_CONTROL:
					sprintf(USART1_tx_buff, "EDID RS232 GUI CONTROL 1111\r\n");
    					UART1_SendBytes((uint8_t *)USART1_tx_buff, strlen(USART1_tx_buff));
					KeyValue=eEDID_RS232_GUI_CONTROL;
					break;
			default:break;
		  }
	}
}
#endif


unsigned char appGetDialSwitchEdidStatus(void)
{
	return KeyValue;
}


 //输入端口的EDID 选择
// 从NVRAM 读取指定的EDID数据写到输入芯片中，保存到输入口的NVRAM EDID 中
// 或者从外部输出口读取EDID 写入9679 中，保存到输入口的NVRAM EDID 中
//  cEdidSelect:
//                     edsEDID_INTERN1~edsEDID_INTERN5, 读取NVRAM 中的内部EDID.
//                    edsEDID_EXTERN1 ~edsEDID_EXTERN4 读取外部接口EDID,
//  cInputPort - 从0 开始算
//  pcEdidData  读取显示器的EDID时的指针
//  eEDIDINPORTSELECT    是进行单路输入edid管理还是所有输入端口edid管理的选择
void appSystemInputPortEdidSet(BYTE cInputPort, eEDIDSELECT cEdidSelect, PCBYTE pcEdidData,eEDIDINPORTSELECT cINPORTSELECT )
{
    BOOL                        bNVRAMEdidValid;
    //BYTE                         cInputEdidSelect = 0;
    BYTE                        i = 0;
    PSYSTEM_SETTING_DATA         psSystemSettingData;
    PINPUTPORT_MANAGER_DATA      psInputPortMgrData;
    BYTE   acEdid[256];

    ASSERT(cInputPort < MAX_IN);
    ASSERT(cEdidSelect < eedsINVALID);
    psSystemSettingData = (PSYSTEM_SETTING_DATA)utilDataMgrReadLockData(nnSYSTEM_SETTING_DATA);
    bNVRAMEdidValid = psSystemSettingData->bNVARMEDID_Inited;
    utilDataMgrUnlock(nnSYSTEM_SETTING_DATA,
                      FALSE);
    psInputPortMgrData  = (PINPUTPORT_MANAGER_DATA)utilDataMgrWriteLockData(nnINPUTPORT_MAMAGER_DATA);
    psInputPortMgrData->acEdidSelect[cInputPort] = cEdidSelect;
    utilDataMgrUnlock(nnINPUTPORT_MAMAGER_DATA,
                      TRUE);
    if (cEdidSelect < edsEDID_EXTERN1)
    {
        // 内部EDID
        if (bNVRAMEdidValid)
        {
            dvNVRAMUserEdidRead(cEdidSelect, acEdid);
        }
    }
    else
    {
        // 选择外部显示器的EDID
	 memcpy(acEdid, pcEdidData, 256);

         // HDMI2.0降为HDMI1.3
        //appSystemHDMI2_0DwonHDMI1_3(acEdid);

    }
    if ((acEdid[0] != 0x00) || (acEdid[1] != 0xff) || (acEdid[7] != 0x00))
    {
        memcpy(acEdid, g_Init_EdidFlashEdidTable, 256);
    }

    if(cINPORTSELECT==SINGLE_INPORT)			//单路输入端口的EDID管理
    {
	   dvNVRAMUserEdidWrite(edsEDID_IN1 + cInputPort, acEdid);
    	   SiiSetRxEdidSramWrite(cInputPort, acEdid, 256,SINGLE_INPORT);
    }
    else if(cINPORTSELECT==ALL_INPORT)			//所有输入端口的EDID管理
    {
	   for(i=0;i<MAX_IN;i++)
	   {
			dvNVRAMUserEdidWrite(edsEDID_IN1 + i, acEdid);
	   }
	   SiiSetRxEdidSramWrite(0, acEdid, 256,ALL_INPORT);
    }
}

//
//  把EDID 数据保存到NVRAM, 并且设置到输入芯片中, 并且保存到对应输入口的EDID NVRAM 中
//  输入端口的EDID 选择
//  cEdidSelect:  - 没有用
//  pcEdidData:  - 指定EDID 数据
void appSystemInputPortEdidDataSet(BYTE cInputPort,eEDIDSELECT cEdidSelect,PCBYTE pcEdidData)
{
    BOOL                        bNVRAMEdidValid;
    //BYTE                         cInputEdidSelect = 0;
    PSYSTEM_SETTING_DATA         psSystemSettingData;
    PINPUTPORT_MANAGER_DATA      psInputPortMgrData;
    //BYTE                         acEdid[256];
    ASSERT(cInputPort < MAX_IN);
    ASSERT(cEdidSelect < eedsINVALID);
    psSystemSettingData = (PSYSTEM_SETTING_DATA)utilDataMgrReadLockData(nnSYSTEM_SETTING_DATA);
    bNVRAMEdidValid = psSystemSettingData->bNVARMEDID_Inited;
    utilDataMgrUnlock(nnSYSTEM_SETTING_DATA,
                      FALSE);
    psInputPortMgrData  = (PINPUTPORT_MANAGER_DATA)utilDataMgrWriteLockData(nnINPUTPORT_MAMAGER_DATA);
    psInputPortMgrData->acEdidSelect[cInputPort] = cEdidSelect;
    utilDataMgrUnlock(nnINPUTPORT_MAMAGER_DATA,
                      TRUE);
   dvNVRAMUserEdidWrite(edsEDID_IN1+cInputPort, (PBYTE)pcEdidData);

/*
    if (cEdidSelect<edsEDID_EXTERN1)
    {
    // 内部EDID
        if (bNVRAMEdidValid)
        {

            dvNVRAMUserEdidRead(cInputEdidSelect, acEdid);
        }
    }
    else
    {
    // 选择外部EDID
    // 如果选择外部EDID, 在输出口HPD 变化时候需要重新读取
           SiiTxEdidGetEdidData(utilOutputPortToInstance( cEdidSelect-edsEDID_EXTERN1)  ,acEdid);
    }

*/
   SiiSetRxEdidSramWrite(cInputPort, (PBYTE)pcEdidData, 256,SINGLE_INPORT);
}

eEDIDSELECT appSystemInputPortEdidGet(BYTE cInputPort)
{
    eEDIDSELECT eEdidSelect;
    PINPUTPORT_MANAGER_DATA      psInputPortMgrData;
    psInputPortMgrData  = (PINPUTPORT_MANAGER_DATA)utilDataMgrReadLockData(nnINPUTPORT_MAMAGER_DATA);
    eEdidSelect = psInputPortMgrData->acEdidSelect[cInputPort];
    utilDataMgrUnlock(nnINPUTPORT_MAMAGER_DATA,
                      FALSE);
    return eEdidSelect;
}

// 读出输入端口的EDID 数据
void appSystemInputPortEdidDataGet(BYTE cInputPort,PBYTE pEdidData)
{

     dvNVRAMUserEdidRead(edsEDID_IN1+cInputPort, pEdidData);
}

void appInputHDCPCompatible(void)
{
    static BYTE inPort;

     if(!SiiPlatformTimerExpired(etINPUT_HDCP))
    	{
  	   	return; 		// time not enougth
    	}
	
    PINPUTPORT_MANAGER_DATA       psInputPortMgrData;
    psInputPortMgrData = (PINPUTPORT_MANAGER_DATA)utilDataMgrWriteLockData(nnINPUTPORT_MAMAGER_DATA);
   if(inPort<MAX_IN)
    {
       BOOL bCurrentHDCP = Sii9396RxHDCPGet(inPort);
       psInputPortMgrData->abCurrentHDCP[inPort]=bCurrentHDCP;
       inPort++;
    }
     if(inPort==MAX_IN)
        inPort=0;	
    utilDataMgrUnlock(nnINPUTPORT_MAMAGER_DATA,
                      TRUE);

    SiiPlatformTimerSet(etINPUT_HDCP,mS_TO_TICKS(1000) ,0xFF);   // 1s循环一次，重新设置时间
	
}



