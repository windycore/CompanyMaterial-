
// 把输入口cInput 切到指定的输出口上
//cInput: 输入端口号,Begin from 0
//cPortNumber: 输出端口数目 Begin from 1
//...  : 输出端口号
// 把 第0口切换到 0,1,2,3 口
//eg: appSystemSwitcherSet(0,4,0,1,2,3)
void appSystemSwitcherSet(BYTE cInput, BYTE cPortNumber, ...);
//cOutPortList  : 输出端口号数组
void appSystemSwitcherPortSet(BYTE cInput, BYTE cPortNumber, PBYTE cOutPortList);
//保存当前切换状态到指定的场景里
void appSystemSwitcherScenceSave(BYTE cScence);

//调用指定的场景
void appSystemSwitcherScenceCall(BYTE cScence);

//删除指定的场景
void appSystemSwitcherScenceDel(BYTE cScence);





// 把 NVRAM 里保存的切换关系设置到
// 一般开机会调用这个函数
void appSystemSwitcherSetStart(void);
//恢复上一次的切换关系
void appSystemSwitcherUndo(void);

//关闭所有的输出
void appSystemSwitcherOutportCloseAll(void);
//恢复关闭前状态
void appSystemSwitcherOutportRecoverAll(void);

// 主循环调用
void appSystemHDCPProcess(void);
// 设置输入口的EDID,
void appSystemInputPortEdidSet(BYTE cInputPort,eEDIDSELECT cEdidSelect);

// 电源管理， 进入POWEROFF, STANDBY 调用这个函数
void appPowerMgrPowerStateSet(ePOWERSTATE eNewState)

// 设置输出是DVI 还是HDMI
void SiiTxOutputInterfaceSet(BYTE cInstance, txHdmiMode_t mode)

// HDMI输出 声音开关
// HDMI 声音开关，并且保存状态到NVRAM,这个函数不太科学
void appSystemHDMITXAudioOutEnableSet(BYTE cInstance, BOOL bEnable)

//----------------------------------------9533 ------------------------------------------------------

// 使能9533 的TX HDCP
BOOL dvSii9533TXHDCPSetStart(BYTE cInstance,BOOL bEnable)


// 得到分辨率
BOOL  dvSii9533RXResolutionGet(BYTE cInstance,INT* pHorizPixel, INT *pVertLine,INT *pTmdsClock)

// 得到当前9533 TX HDCP 是否打开
BOOL dvSii9533TXHDCPGet(BYTE cInstance)

// 
// 读取输出口的EDID, 在输出口HPD 变化时候需要重新读取
    SiiTxEdidGetEdidData(utilOutputPortToInstance( cEdidSelect-edsEDID_EXTERN1)  ,acEdid);

//------------------------------------------9679------------------------------------------------------

// 得到 9679 HDCP 输入状态
// return : true have HDCP
//          false no HDCP
BOOL dvSiiDrvAdaptRxHDCPGet(BYTE cInstance)

// 得到9679  输入端是否有接信号
// return TRUE: connected
BOOL dvSiiDrvAdaptRxConnectGet(BYTE cInstance)

// 控制9679 输入端口的HPD 
void dvSiiDrvAdaptRxHpdSet(BYTE cInstance, SiiDrvAdaptInpCtrl_t hpd);

//更新输入端的Edid 
void dvSiiDrvAdaptRxEdidSramWrite(BYTE cInstance,
                                  uint16_t offset,
                                  const uint8_t  *pData,
                                  uint16_t length);
								  
// 设置输9679 是否输出信号
void  dvSiiDrvAdaptTxTmdsOutSet(BYTE cInstance,  SiiDrvAdaptTmdsOut_t tmdsCtrl)

SiiDrvAdaptTmdsOut_t SiiDrvAdaptTxTmdsOutGet(SiiInst_t inst);

// 得到9679  输出端是否使能?
// return TRUE: Is Enable
//           Fasle is Disable
BOOL dvSiiDrvAdaptTxTmdsOutEnGet(BYTE cInstance)



// 设置显示的消息到UI 模块
appUIUartMessageSet(NULL, acMessage2);
//  更改UI 的状态
appUIStateChange(uiUART_MESSAGE);


EdidTxCompose

EdidDecodeBlock0
EdidBlock0Check


SkAppDevicePower

SkAppLowPowerStandby

NVIC_PriorityGroup_0：则只看NVIC_IRQChannelSubPriority 
NVIC_PriorityGroup_4：则只看NVIC_IRQChannelPreemptionPriority

                                  NVIC_IRQChannelPreemptionPriority  NVIC_IRQChannelSubPriority

USART1   NVIC_PriorityGroup_0           x                                    4
USART2   NVIC_PriorityGroup_0           1                                    5

TIM2(x)     NVIC_PriorityGroup_0         0                                   1
TIM3        NVIC_PriorityGroup_0         0                                   2
KEY         NVIC_PriorityGroup_0                                            0x0E
IR          NVIC_PriorityGroup_0                                            0x0F




                                  NVIC_IRQChannelPreemptionPriority  NVIC_IRQChannelSubPriority

USART1      NVIC_PriorityGroup_2           x                              4
USART2      NVIC_PriorityGroup_2           1                              5

TIM2(x)     NVIC_PriorityGroup_2           0                              1
TIM3        NVIC_PriorityGroup_2           0                              2
KEY         NVIC_PriorityGroup_2                                          0x0E
IR          NVIC_PriorityGroup_2                                          0x0F
   