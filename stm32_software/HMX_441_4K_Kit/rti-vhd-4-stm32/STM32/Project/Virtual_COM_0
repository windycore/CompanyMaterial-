/******************** (C) COPYRIGHT 2010 STMicroelectronics ********************
* File Name          : main.c
* Author             : MCD Application Team
* Version            : V3.1.1
* Date               : 04/07/2010
* Description        : Virtual Com Port Demo main file
********************************************************************************
* THE PRESENT FIRMWARE WHICH IS FOR GUIDANCE ONLY AIMS AT PROVIDING CUSTOMERS
* WITH CODING INFORMATION REGARDING THEIR PRODUCTS IN ORDER FOR THEM TO SAVE TIME.
* AS A RESULT, STMICROELECTRONICS SHALL NOT BE HELD LIABLE FOR ANY DIRECT,
* INDIRECT OR CONSEQUENTIAL DAMAGES WITH RESPECT TO ANY CLAIMS ARISING FROM THE
* CONTENT OF SUCH FIRMWARE AND/OR THE USE MADE BY CUSTOMERS OF THE CODING
* INFORMATION CONTAINED HEREIN IN CONNECTION WITH THEIR PRODUCTS.
*******************************************************************************/

/* Includes ------------------------------------------------------------------*/
#include <string.h>
#include <stdlib.h>
#include <stdio.h> 
#include <math.h> 
#include "stm32f10x.h"
#include "usb_lib.h"
#include "usb_desc.h"
#include "hw_config.h"
//#include "usb_pwr.h"
//下面部分跟AVR一样的格式/////////////////
#include "board.h"
#include "initPeriph.c"
////////////////////////6623////////////////
#include "main.h"
#include "cat6023.h"
#include "cat6613.h"
#include "Mcu.h"
#include "IO.h"
#include "EDID.h" 
#include "Utility.h"
#include "HDCP.h"
#include "TimerProcess.h"
#include "uart.h"
#include "key_led_lcd.h"
#include "LCD_scan.h"
#include "IIC_EE_4604_EDID_other.h"
#include "Driver_9187.h"
#include "IR.h"
#include "switch_driver.h"
#include "CPLD.h"
#include "HDCP_Other_process.h"

void Init_All_Periph(void);

extern uint16_t second_9187;
uint16_t sys_run_count = 0;
uint32_t sys_run_time_count = 0;
/////////////////////////////////
BYTE DeviceID = 0;
BYTE bPreSrcAudRdy[DevNum] = {FALSE};

uint8_t SiIRegioRead ( uint16_t regAddr );

////////////////////////////////////////////
/* Private functions ---------------------------------------------------------*/
/* 1US延时，已通过示波器验证过*/
void delay_nus(uint16_t time)  
{
   uint8_t j;
   while(time--!=0)
   {
      for(j=0;j<8;j++) ;
   }
}
/* 1MS延时，已通过示波器验证过*/
void delay_nms(uint16_t count)
{
   uint16_t j;
   while(count--!=0)
   {
      for(j=0;j<10000;j++) ;
   }
}

void InitHdmi_Variables(BYTE deviceID)
{
  VState[deviceID]=VSTATE_5VOff;
  AState[deviceID]=ASTATE_AudioOff;

  MuteResumingTimer[deviceID]=0;
  VideoCountingTimer[deviceID]=0;
  AudioCountingTimer[deviceID]=0;

  MuteByPKG[deviceID]=OFF;

  bDisableAutoAVMute[deviceID]=0;
  bOutputVideoMode[deviceID]=F_MODE_EN_UDFILT;
  bGetSyncFailCount[deviceID]=0;
  ucAudioSampleClock[deviceID]=0x03;
  ucHDMIAudioErrorCount[deviceID]=0;

  MuteAutoOff[deviceID]=FALSE;
  bUpHDMIMode[deviceID]=FALSE;
  bUpHDCPMode[deviceID]=FALSE;

  C6623AudioBypass[deviceID] = TRUE;
}

void AVR_TX_AUDCTROL()
{
  BYTE bSrcAudRdy;
	AUDIO_CAPS TX_AudioCaps;
	RX_REG_AUDIO_CHSTS TX_Channelstatus;
	Audio_InfoFrame audioinfoframe;

	if(C6623AudioBypass[DeviceID] == TRUE)
	{
 		bSrcAudRdy = getRXAudioInfo(&TX_AudioCaps,&TX_Channelstatus);

		if(bPreSrcAudRdy[DeviceID] != bSrcAudRdy)
		{
    	bPreSrcAudRdy[DeviceID] = bSrcAudRdy;
			if(bSrcAudRdy)
			{
				GetAudioInfoFrame(&audioinfoframe);
				SetAudioInfoFrame(&audioinfoframe);
				SetTxAudioCapability(TX_AudioCaps);
				TurnONTxAudio(TRUE);
		  }
			else
			{
		    TurnONTxAudio(FALSE);
			}
    }
	}	
}

//系统定时器  20ms
void SysTick_Handler(void)
{
	 unsigned char i = 0;
   if(rxdelay_USART1 > 0)   rxdelay_USART1 -= 20;
   else 
   {
   	 if(uart_data_in_start == 1) 
   	 {
   	 	uart_data_in_end = 1; //串口数据接收完成，可以去处理了
   	 	uart_data_in_start = 0;
   	 }
   }		
   if(Key_delay > 0)        Key_delay -= 20;
   if(IR_Delay > 0)         IR_Delay -= 20;
   if(second_9187 > 0)      second_9187 -= 20;
   if(sys_delay > 0)        sys_delay -- ;         	
   	
   shanshuo_count ++ ;
   if(shanshuo_count>=25)
   {
   	  shanshuo_count = 0;
   	  if(Key_long_delay > 0) Key_long_delay -- ;
   	  shanshuo_delay ++ ;
   	  if(shanshuo_delay>250)  shanshuo_delay = 0;
   } 
   
   led_count ++	;
   if(led_count >= 50)	//秒溢出
   {   	    	  	  	  
   	  led_count = 0;
   	  sys_run_time_count ++ ;
   	  if(BackLight_delay>0)  BackLight_delay--;
   	  if(DEMO_delay>0)  DEMO_delay--;
   	  	
   	  for(i=0;i<31;i++) 
   	  {
   	  	 if((led_on_time[i]!=0xff)&&(led_on_time[i] > 0))  led_on_time[i] -- ;
   	  }
   }     
}

//管理的6个6623的时间控制单元是公用的    20ms
void TIM2_IRQHandler(void)
{
	TIM_ClearFlag(TIM2,TIM_FLAG_Update);
	ucTickCount++;	 
}

void  global_set_6623(void)
{
	HWResetPin(0);
	delay_nms(60);
	HWResetPin(1);
	initTimerTask();
}

void  Init_6623(void)
{
	for(DeviceID=0;DeviceID<DevNum;DeviceID++)
	{
		device_slect_6623(DeviceID+1);
		
		m_HPDGPIO[DeviceID]=FALSE;	//2011/02/18 for select port issue	
			
		//_TX_HDCP_On[DeviceID] = 0;
		//_TX_HDCP_temp[DeviceID] = 0;
		
		#if(IN_OUT == 1) //输出的话，那么输入是不需要执行RxHDCP_Handler();
		_RX_HDCP_temp[DeviceID] = 0;
		_RX_HDCP_ON[DeviceID] = 0;
		#else
		_RX_HDCP_temp[DeviceID] = 1;
		_RX_HDCP_ON[DeviceID] = 1;
		#endif
		
		TurnOff_HDMIRX(); //2010/07/21
	  IWDG_ReloadCounter();//喂狗
		InitHdmi_Variables(DeviceID);
	  
		InitTxDev(TRUE);
	
		C6613_Check_EMEM_sts();
	
		TurnONTxAudio(FALSE);
	
		m_BackEndActive[DeviceID]=TRUE;	//2010/07/21
		
		Set6233audioByPass(TRUE);
	  //printf("\n-------------------------------------while(1)---------------------------------\n");
	  #ifdef EnableAdjustEQ
	    HDMIRX_WriteI2C_Byte(0x95,0x87);		//for initial 6023 EQ value.
	  #endif
	  
	  #if(IN_OUT == 1) //输出的话，那么输入的HDCP引擎可以关掉
	     HDMIRX_WriteI2C_Byte(REG_RX_HDCP_CTRL,0x88); //关闭输入HDMI的  HDCP引擎
	  #endif
  }
}

void process_6623(void)
{	
	_6623_working = 1;
	for(DeviceID=0;DeviceID<DevNum;DeviceID++)
	//DeviceID = 3;
	{
		if((uart_data_in_end == 0)&&(ir_data_in_end == 0))
		{  
			device_slect_6623(DeviceID+1);
			/////////////6623/////////////
			if(_TX_HDCP_temp[DeviceID] != _TX_HDCP_On[DeviceID])
			{
				 HDCP_ResetAuthenticate();
				 _TX_HDCP_On[DeviceID] = _TX_HDCP_temp[DeviceID] ;
				 i2c_EE_write_one_byte(OUT_hdcp_staues_add+DeviceID,_TX_HDCP_On[DeviceID]);
			}
			ProcessMultiTimerTask();	
			Interrupt_Handler();
			Timer_Handler();		
			Video_Handler();
			#ifdef _RX_HDCP_STATE_MACHINE_
			   if(_RX_HDCP_ON[DeviceID]==1)  RxHDCP_Handler();		     
			#endif
	    IWDG_ReloadCounter();//喂狗	
			AVR_TX_AUDCTROL();
			TxInterrupt_Handler();
			TxVideo_Handler();		
			TX_AudioHandler();
			#ifdef _TX_HDCP_STATE_MACHINE_								     
				if(_TX_HDCP_On[DeviceID]==1)  TxHDCP_Handler();		
			#endif	
			IWDG_ReloadCounter();//喂狗	
			disconnect_6623();
	  }
	  else
	  {
	  	_6623_working = 0;	
	  	return ;
	  }	
	  		  
  }
  _6623_working = 0;	
}

void recall_sys_inf(void)
{
	uint8_t i = 0 ,j = 0;
	//恢复断电前的通道值
	recall_Channel_beforePOWER_down();
	//处理系统运行次数
	sys_run_count = (i2c_EE_read_one_byte(sys_run_count_add+1)<<8);
	sys_run_count |= i2c_EE_read_one_byte(sys_run_count_add);
	sys_run_count ++ ;
	i2c_EE_write_one_byte(sys_run_count_add+1,sys_run_count>>8);
	i2c_EE_write_one_byte(sys_run_count_add,sys_run_count);
	//恢复出系统运行时间
	sys_run_time_count = (i2c_EE_read_one_byte(sys_run_time_count_add+3)<<24);
	sys_run_time_count |= (i2c_EE_read_one_byte(sys_run_time_count_add+2)<<16);
	sys_run_time_count |= (i2c_EE_read_one_byte(sys_run_time_count_add+1)<<8);
	sys_run_time_count |= i2c_EE_read_one_byte(sys_run_time_count_add);
	//HDCP管理模式
	HDCP_AUTO_FLAG = i2c_EE_read_one_byte(auto_hdcp_manage_add);
	//输入端HDCP兼容变量
	for(i=0;i<MAX_IN_OUT;i++) HDCP_IN_EN[i] = i2c_EE_read_one_byte(IN_hdcp_en_add+i);
	//输出端HDCP状态变量
	for(i=0;i<DevNum;i++) _TX_HDCP_temp[i] = i2c_EE_read_one_byte(OUT_hdcp_staues_add+i);
	//系统锁定状态变量
	System = i2c_EE_read_one_byte(sys_lock_flag_add);
	//系统信息反馈状态变量
	Re_Message = i2c_EE_read_one_byte(RE_message_add);
	//红外模式
	IR_carrier_mode = i2c_EE_read_one_byte(IR_carrier_mode_add);
	if(IR_carrier_mode == 1)//红外载波强制
  {
     send_data_to_FPGA(0xDF) ;
     if(check_ack())  send_data_to_FPGA(0xDF) ;
  }
  else  //红外载波跟随
  {
  	 send_data_to_FPGA(0xDE) ;
     if(check_ack())  send_data_to_FPGA(0xDE) ;
  }
  //PWON/OFF 模式数据
  for(i=0;i<MAX_IN_OUT;i++)
  {
  	for(j=0;j<48;j++) 
  	{
  	  PWON_rBuff[i][j] = i2c_EE_read_one_byte(uart_data_add+i*64+j);
  	  if(PWON_rBuff[i][j] == 0)
  	  {
  	  	 PWON_datalen[i] = j;
  	  	 break ;
  	  }
  	}
  }
  IWDG_ReloadCounter();//喂狗	
  for(i=0;i<MAX_IN_OUT;i++)
  {
  	for(j=0;j<48;j++)
  	{
  		 PWOFF_rBuff[i][j] = i2c_EE_read_one_byte(uart_data_add+256+i*64+j);
  		 if(PWOFF_rBuff[i][j] == 0)
  	   {
  	  	 PWOFF_datalen[i] = j;
  	  	 break ;
  	   }
  	}
  }
}

void sys_check(void)
{
	uint8_t i = 0,j = 0;
  uint8_t data_temp[2];
  //开机次数
	sprintf(USART1_tx_buff,"Boot times is %d \r\n",sys_run_count);
	UART1_SendBytes((uint8_t *)USART1_tx_buff,strlen(USART1_tx_buff));
  //运行时间
	sprintf(USART1_tx_buff,"Running time is %d S \r\n",sys_run_time_count);
	UART1_SendBytes((uint8_t *)USART1_tx_buff,strlen(USART1_tx_buff));
	//EERPOM 32检测
	i2c_EE_write_one_byte(0x40,0x55);
	if(i2c_EE_read_one_byte(0x40) == 0x55)  sprintf(USART1_tx_buff,"24C32 is OK !\r\n");
	else sprintf(USART1_tx_buff,"24C32 is Fail !\r\n");
	UART1_SendBytes((uint8_t *)USART1_tx_buff,strlen(USART1_tx_buff));
	//9187 检测
	for(i=0;i<MAX_IN_OUT;i++)
	{
		 device_slect_9187(i+1);
		 delay_nms(1);
		 if(SiIRegioRead(0x002) == 0x87)  sprintf(USART1_tx_buff,"9187 conect to IN HDMI %d is OK !\r\n",i+1);
		 else sprintf(USART1_tx_buff,"9187 conect to IN HDMI %d is Fail !\r\n",i+1);
		 UART1_SendBytes((uint8_t *)USART1_tx_buff,strlen(USART1_tx_buff)); 
	}
	disconnect_9187();
	//PI3HDMI412检测
	for(i=0;i<2;i++)
	{
		READ_PI3HDMI412(0xC2+i*4, data_temp);
		if(data_temp[0] == 0xc1)  sprintf(USART1_tx_buff,"9PI3HDMI412 %d is OK !\r\n",i+1);
		else sprintf(USART1_tx_buff,"9PI3HDMI412 %d is Fail !\r\n",i+1);
		UART1_SendBytes((uint8_t *)USART1_tx_buff,strlen(USART1_tx_buff)); 
	}
	//4604 检测
	if(read_4604(_4604_add,0x12) == 0x00)  sprintf(USART1_tx_buff,"4604 is OK !\r\n");
	else sprintf(USART1_tx_buff,"4604 is Fail !\r\n");
	UART1_SendBytes((uint8_t *)USART1_tx_buff,strlen(USART1_tx_buff)); 
	//6623 检测
	for(i=0;i<DevNum;i++)
	{
		device_slect_6623(i+1);
		delay_nms(1);
		j = HDMIRX_ReadI2C_Byte(REG_RX_HDCP_CTRL);
		if(j == 0x88)
		{
			if(i==0) sprintf(USART1_tx_buff,"6623 conect to out HDMI 2 is OK !\r\n");
			else if(i==1) sprintf(USART1_tx_buff,"6623 conect to out HDMI 1 is OK !\r\n");
			else sprintf(USART1_tx_buff,"6623 conect to HD Base %d is OK !\r\n",i-1);
		}
		else  
		{
			if(i==0) sprintf(USART1_tx_buff,"6623 conect to out HDMI 2 is Fail! !\r\n");
			else if(i==1) sprintf(USART1_tx_buff,"6623 conect to out HDMI 1 is Fail! !\r\n");
			else sprintf(USART1_tx_buff,"6623 conect to HD Base %d is Fail! !\r\n",i-1);
		}
	  UART1_SendBytes((uint8_t *)USART1_tx_buff,strlen(USART1_tx_buff)); 
	}	
}

void init_devices(void)
{
	Init_All_Periph();//
	global_set_6623();//RESET管脚	
	delay_nms(400);
	IWDG_ReloadCounter();//喂狗	
	init_uart1_part();
	USART1_Configuration();
	sprintf(USART1_tx_buff,"System Initializing...\r\n");
	UART1_SendBytes((uint8_t *)USART1_tx_buff,strlen(USART1_tx_buff));
	//初始化9539
	init_9539();
	//EEPROM第一次需要初始化
	if(i2c_EE_read_one_byte(first_use_add) != 0x53)  EEPROM_init();
	//恢复断电前的系统信息
	recall_sys_inf();
	//初始化9187
	Init_9187();
	//初始化PI3HDMI412  地址是0xC2   0xC6
	//WRITE_PI3HDMI412(0xC2,0x41,0x41);
	WRITE_PI3HDMI412(0xC2,0x41,0x31);
	delay_nms(10);
	//WRITE_PI3HDMI412(0xC6,0x41,0x41);
	WRITE_PI3HDMI412(0xC6,0x41,0x31);
	//初始化4604
	InitAdn4604();
	//上电时开启风扇
	//初始化6623	
	Init_6623();
	GPIOC->BSRR = GPIO_Pin_6;	
	//初始化LCD	
	sprintf(USART1_tx_buff,"Initialization Finished\r\n");
  UART1_SendBytes((uint8_t *)USART1_tx_buff,strlen(USART1_tx_buff));
  sprintf(USART1_tx_buff,"%s \r\n",sys_type);
	UART1_SendBytes((uint8_t *)USART1_tx_buff,strlen(USART1_tx_buff));
	sprintf(USART1_tx_buff,"%s%s\r\n\r\n",sys_name,Version);
	UART1_SendBytes((uint8_t *)USART1_tx_buff,strlen(USART1_tx_buff));
	
	LCD_init();
  LCD_init();
	strcpy(D1, sys_type);
  strcpy(D2, sys_name);
  LCD_LineRefresh(D1, LINE1);
  LCD_LineRefresh(D2, LINE2);	
  IWDG_ReloadCounter();//喂狗		
}
/*******************************************************************************
* Function Name  : main.
* Description    : Main routine.
* Input          : None.
* Output         : None.
* Return         : None.
*******************************************************************************/
int main(void)
{
	Set_System();
	/************USB初始化*********************/
	Set_USBClock();
	USB_Interrupts_Config();
	USB_Init(); 	
	//////////////////////////////////////////// 	
	init_devices();	
	switch_process();//在这里就执行通道切换
	//send_data_to_FPGA(0xff) ;	
	//if(check_ack())  send_data_to_FPGA(0xff) ;
	KEY_In_interruptConfig();
	while (1)
	{
		IWDG_ReloadCounter();//喂狗	
		Uart1_process();
		IR_received();
		if((System == ON)&&((powerflag == 0))) Keyboard();		
		LED_Display();		
	  process_6623();
	  switch_process();
	  hdcp_in_staues_change_process();
	  SaveCurrentChannel();  	  
	  sys_lcd_led_process();	
	  HD_BASE_LED_check();				
	}
}
#ifdef USE_FULL_ASSERT
/*******************************************************************************
* Function Name  : assert_failed
* Description    : Reports the name of the source file and the source line number
*                  where the assert_param error has occurred.
* Input          : - file: pointer to the source file name
*                  - line: assert_param error line source number
* Output         : None
* Return         : None
*******************************************************************************/
void assert_failed(uint8_t* file, uint32_t line)
{
  /* User can add his own implementation to report the file name and line number,
     ex: printf("Wrong parameters value: file %s on line %d\r\n", file, line) */

  /* Infinite loop */
  while (1)
  {}
}
#endif

/******************* (C) COPYRIGHT 2010 STMicroelectronics *****END OF FILE****/
